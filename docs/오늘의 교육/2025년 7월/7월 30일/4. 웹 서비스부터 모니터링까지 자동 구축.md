---
layout: default
title: 4. 웹 서비스부터 모니터링까지 자동 구축
parent: 7월 30일
nav_order: 38
---

# 2025년 7월 30일 교육 내용

오늘 배운 내용을 여기에 정리합니다.


## 이 프로젝트는 무엇인가요?
이 프로젝트는 '웹사이트라는 식당'의 전체 주방과 홀을 자동으로 건설하고 운영하는 시스템과 같습니다.

HAProxy (로드밸런서): 손님(사용자 트래픽)이 몰려들 때, 빈 테이블(웹 서버)로 안내해주는 **'매니저'**입니다. 한 웨이터에게만 손님이 몰리지 않게 조절합니다.

Nginx (웹 서버): 손님에게 메뉴판(웹 페이지)을 보여주고 음식을 서빙하는 **'웨이터'**들입니다.

MariaDB (데이터베이스): 모든 음식 재료(사용자 정보, 게시글 등)를 신선하게 보관하는 **'주방 냉장고'**입니다.

Ansible: 이 모든 구조를 설계도(site.yml) 한 장만 보고 몇 분 만에 자동으로 건설하는 **'건설사'**입니다.

## 어디에 활용하나요?
거의 모든 종류의 현대적인 웹 서비스를 구축하는 데 사용됩니다. 예를 들어,

온라인 쇼핑몰: 수많은 방문객을 '매니저(HAProxy)'가 여러 '웨이터(Nginx)'에게 분산시키고, '냉장고(MariaDB)'에서 상품과 고객 정보를 꺼내 보여줍니다.

블로그 또는 뉴스 사이트: 위와 동일한 구조로 안정적으로 콘텐츠를 제공합니다.

이런 자동화 코드가 있으면, 새로운 서버가 필요할 때마다 몇 시간 걸리던 작업을 몇 분 만에 끝낼 수 있습니다.

## 모니터링은 왜 필요한가요?
모니터링은 **식당이 잘 돌아가는지 24시간 지켜보는 '종합 관제실'**과 같습니다.

## 무엇을 확인하나요?
Prometheus (데이터 수집가): 모든 서버(매니저, 웨이터, 냉장고)를 계속 돌아다니면서 중요한 수치들을 쉴 새 없이 기록하는 **'기록원'**입니다.

CPU 사용량: 웨이터의 뇌가 과부하 걸리지 않았나?

메모리 사용량: 웨이터가 너무 많은 주문을 받아 기억을 못 하고 있지는 않나?

디스크 공간: 냉장고가 꽉 차서 더 이상 재료를 넣을 수 없나?

네트워크 트래픽: 손님이 갑자기 너무 많이 몰려와서 문이 막히지는 않았나?

Grafana (종합 상황판): 기록원(Prometheus)이 수집한 모든 데이터를 **한눈에 보기 쉬운 그래프와 차트로 보여주는 '대시보드'**입니다.

## 확인하는 용도
문제 예측 및 예방: "어, 냉장고 공간이 80%나 찼네. 꽉 차기 전에 미리 공간을 늘려야겠다!" 와 같이, 장애가 발생하기 전에 미리 파악하고 조치할 수 있습니다.

성능 분석: "점심시간에 손님이 가장 많이 몰리는구나. 다음 주에는 이 시간대에 웨이터(웹 서버)를 한 명 더 늘려야겠다." 와 같이, 서비스를 언제 어떻게 확장할지 데이터에 기반하여 결정할 수 있습니다.


# 1단계: 프로젝트 준비 (폴더와 주소록 만들기)
## 1. 새로운 프로젝트 폴더를 만들고 들어갑니다.
mkdir ~/two-tier-infra
cd ~/two-tier-infra


## 2. 서버 목록 파일(hosts)을 만듭니다.
[loadbalancer]: 고객의 모든 요청을 가장 먼저 받는 '정문'
[webservers]: 실제 웹사이트를 보여주는 **'안내 데스크'**들
[dbservers]: 중요한 데이터를 보관하는 '금고'
[monitoring]: 이 모든 것이 잘 돌아가는지 지켜보는 '관제실'

vi hosts

```
[loadbalancer]
an-ksh001 ansible_host=10.10.8.200 ansible_connection=local

[webservers]
an-ksh002 ansible_host=10.10.8.201
an-ksh003 ansible_host=10.10.8.202

[dbservers]
an-ksh004 ansible_host=10.10.8.203

[monitoring]
an-ksh005 ansible_host=10.10.8.204
```

# 2단계: 작업 지시서 작성 (playbook.yml)
an-ksh001에는 웹 서버를, an-ksh002에는 데이터베이스 서버를 설치하도록 두 부분으로 나뉜 작업 지시서를 만듭니다

haproxy 역할: '정문(로드밸런서)' 설치팀의 매뉴얼
nginx 역할: '안내 데스크(웹 서버)' 설치팀의 매뉴얼
mariadb 역할: '금고(데이터베이스)' 설치팀의 매뉴얼
prometheus, grafana 역할: '관제실(모니터링)' 설치팀의 매뉴얼
common, node_exporter 역할: 모든 팀이 공통으로 따라야 하는 기본 안전 수칙 매뉴얼

## --- 플레이: 데이터베이스 서버 설정 ---
vi playbook.yml

```
- name: 2. Configure Database Server
  hosts: dbserver         # hosts 파일의 [dbserver] 그룹을 대상으로 합니다.
  become: true            # 관리자(sudo) 권한으로 실행합니다.

  tasks:
    - name: Install MariaDB (Database)
      ansible.builtin.apt:
        name: mariadb-server
        state: present
        update_cache: yes

    - name: Start and enable MariaDB service
      ansible.builtin.service:
        name: mariadb
        state: started
        enabled: yes
```

ansible-galaxy init 명령어를 사용하여 common 역할에 필요한 기본 폴더와 파일들을 생성해야 합니다.
mkdir roles

common 역할 생성
ansible-galaxy init common --init-path ./roles


tasks/main.yml에 최소한의 작업 추가
vi roles/common/tasks/main.yml

```
---
- name: Update apt cache
  ansible.builtin.apt:
    update_cache: yes


node_exporter 역할 생성
ansible-galaxy init 명령어로 node_exporter 역할의 기본 구조를 만듭니다.
ansible-galaxy init node_exporter --init-path ./roles


tasks/main.yml에 작업 추가
생성된 roles/node_exporter/tasks/main.yml 파일을 열어, 모니터링 에이전트를 설치하는 작업을 추가합니다.
vi roles/node_exporter/tasks/main.yml

---
# tasks file for node_exporter
- name: Download and unpack node_exporter
  ansible.builtin.unarchive:
    src: https://github.com/prometheus/node_exporter/releases/download/v1.8.1/node_exporter-1.8.1.linux-amd64.tar.gz
    dest: /usr/local/bin/
    remote_src: yes
    extra_opts: [--strip-components=1]

- name: Create systemd service file for node_exporter
  ansible.builtin.copy:
    dest: /etc/systemd/system/node_exporter.service
    content: |
      [Unit]
      Description=Node Exporter
      [Service]
      ExecStart=/usr/local/bin/node_exporter
      [Install]
      WantedBy=multi-user.target

- name: Enable and start node_exporter service
  ansible.builtin.systemd:
    name: node_exporter
    daemon_reload: yes
    state: started
    enabled: yes
```

다음 단계: mariadb 역할 생성 및 작업 추가
mariadb 역할 생성
ansible-galaxy init 명령어로 mariadb 역할의 기본 구조를 만듭니다.
ansible-galaxy init mariadb --init-path ./roles


tasks/main.yml에 작업 추가
생성된 roles/mariadb/tasks/main.yml 파일을 열어, 데이터베이스 서버를 설치하고 실행하는 작업을 추가합니다.
vi roles/mariadb/tasks/main.yml

```
---
# tasks file for mariadb
- name: Install MariaDB server package
  ansible.builtin.apt:
    name: mariadb-server
    state: present
    update_cache: yes

- name: Start and enable MariaDB service
  ansible.builtin.service:
    name: mariadb
    state: started
    enabled: yes
```

다음 단계: nginx 역할 생성 및 작업 추가
nginx 역할 생성
ansible-galaxy init nginx --init-path ./roles


tasks/main.yml에 작업 추가
roles/nginx/tasks/main.yml 파일을 열어, Nginx를 설치하고 간단한 테스트 페이지를 만드는 작업을 추가합니다.
vi roles/nginx/tasks/main.yml

```
---
# tasks file for nginx
- name: Install Nginx
  ansible.builtin.apt:
    name: nginx
    state: present
    update_cache: yes

- name: Create a simple index.html for testing
  ansible.builtin.copy:
    content: "<h1>Welcome to Web Server {{ ansible_hostname }}</h1>"
    dest: /var/www/html/index.html
    mode: '0644'

- name: Start and enable Nginx service
  ansible.builtin.service:
    name: nginx
    state: started
    enabled: yes
```

다음 단계: haproxy 역할 생성 및 작업 추가
haproxy 역할 생성
ansible-galaxy init haproxy --init-path ./roles


설정 파일의 '설계도' 만들기 (templates 디렉터리)
HAProxy 설정 파일을 동적으로 만들기 위해 템플릿 파일이 필요합니다
## 템플릿 파일 작성
vi roles/haproxy/templates/haproxy.cfg.j2

```
global
    log /dev/log    local0
    log /dev/log    local1 notice
    chroot /var/lib/haproxy
    stats socket /run/haproxy/admin.sock mode 660 level admin expose-fd listeners
    stats timeout 30s
    user haproxy
    group haproxy
    daemon

defaults
    log     global
    mode    http
    option  httplog
    option  dontlognull
    timeout connect 5000
    timeout client  50000
    timeout server  50000

frontend http_front
    bind *:80
    default_backend http_back

backend http_back
    balance roundrobin
    {% for host in groups['webservers'] %}
    server {{ hostvars[host].inventory_hostname }} {{ hostvars[host].ansible_host }}:80 check
    {% endfor %}
```

tasks/main.yml에 작업 추가
이제 roles/haproxy/tasks/main.yml 파일을 열어 HAProxy를 설치하고, 위에서 만든 템플릿으로 설정 파일을 배포하는 작업을 추가합니다.
vi roles/haproxy/tasks/main.yml

```
---
# tasks file for haproxy
- name: Install HAProxy
  ansible.builtin.apt:
    name: haproxy
    state: present
    update_cache: yes

- name: Deploy HAProxy configuration file from template
  ansible.builtin.template:
    src: haproxy.cfg.j2
    dest: /etc/haproxy/haproxy.cfg
    mode: '0644'
  notify: Restart HAProxy

- name: Start and enable HAProxy service
  ansible.builtin.service:
    name: haproxy
    state: started
    enabled: yes
```
@ 핸들러를 위한 handlers/main.yml 파일도 만들어야 합니다.


서비스 재시작을 위한 핸들러 추가
설정 파일이 변경될 때만 HAProxy를 재시작하도록 핸들러를 만듭니다

@ 핸들러 파일 작성
vi roles/haproxy/handlers/main.yml

```
---
# handlers file for haproxy
- name: Restart HAProxy
  ansible.builtin.service:
    name: haproxy
    state: restarted
```

prometheus 역할 생성 및 작업 추가
Prometheus는 모든 서버에서 node_exporter가 수집한 정보를 저장하는 역할을 합니다.
ansible-galaxy init prometheus --init-path ./roles


설정 파일 템플릿 작성 (templates/prometheus.yml.j2)
vi roles/prometheus/templates/prometheus.yml.j2

```
global:
  scrape_interval: 15s

scrape_configs:
  - job_name: 'node_exporter'
    static_configs:
      - targets:
        {% for host in groups['all'] %}
        - '{{ hostvars[host].ansible_host }}:9100'
        {% endfor %}
```

작업 파일 작성 (tasks/main.yml)
vi roles/prometheus/tasks/main.yml

```
---
- name: Download and unpack prometheus
  ansible.builtin.unarchive:
    src: https://github.com/prometheus/prometheus/releases/download/v2.53.0/prometheus-2.53.0.linux-amd64.tar.gz
    dest: /usr/local/bin/
    remote_src: yes
    extra_opts: [--strip-components=1]

- name: Deploy prometheus configuration
  ansible.builtin.template:
    src: prometheus.yml.j2
    dest: /usr/local/bin/prometheus.yml

- name: Create systemd service file for prometheus
  ansible.builtin.copy:
    dest: /etc/systemd/system/prometheus.service
    content: |
      [Unit]
      Description=Prometheus
      [Service]
      ExecStart=/usr/local/bin/prometheus --config.file=/usr/local/bin/prometheus.yml
      [Install]
      WantedBy=multi-user.target

- name: Enable and start prometheus service
  ansible.builtin.systemd:
    name: prometheus
    daemon_reload: yes
    state: started
    enabled: yes
```

grafana 역할 생성 및 작업 추가
Grafana는 Prometheus가 수집한 데이터를 멋진 대시보드로 보여주는 역할을 합니다.
ansible-galaxy init grafana --init-path ./roles


작업 파일 작성 (tasks/main.yml)
vi roles/grafana/tasks/main.yml

```
---
- name: Add Grafana GPG key
  ansible.builtin.get_url:
    url: https://apt.grafana.com/gpg.key
    dest: /usr/share/keyrings/grafana.key
    mode: '0644'

- name: Add Grafana repository
  ansible.builtin.apt_repository:
    repo: "deb [signed-by=/usr/share/keyrings/grafana.key] https://apt.grafana.com stable main"
    state: present

- name: Install Grafana
  ansible.builtin.apt:
    name: grafana
    state: present
    update_cache: yes

- name: Start and enable Grafana service
  ansible.builtin.service:
    name: grafana-server
    state: started
    enabled: yes
```

ansible-galaxy init으로 만든 각 역할들은 독립적인 부품과 같습니다. site.yml은 이 부품들을 어떤 순서로, 어떤 서버 그룹에 조립할지 지시하는 메인 플레이북
vi site.yml

```
---
- name: 1. 모든 서버에 공통 설정 및 모니터링 에이전트 적용
  hosts: all
  become: true
  roles:
    - common
    - node_exporter

- name: 2. 데이터베이스 서버 구성
  hosts: dbservers
  become: true
  roles:
    - mariadb

- name: 3. 웹 서버 구성
  hosts: webservers
  become: true
  roles:
    - nginx

- name: 4. 로드 밸런서 구성
  hosts: loadbalancer
  become: true
  roles:
    - haproxy

- name: 5. 모니터링 서버 구성
  hosts: monitoring
  become: true
  roles:
    - prometheus
    - grafana
```

## 여기서 더 나아가 실무 전문가 수준으로 만들기 위해 아래 두 가지를 추가하라고 제안
### 1. group_vars를 이용한 변수 관리: 플레이북을 더 깔끔하게 만들고 변수를 체계적으로 관리합니다.
### 2. ansible-vault를 이용한 민감 정보 암호화: 데이터베이스 비밀번호 같은 중요한 정보를 안전하게 보호합니다.

### 1. group_vars로 변수 분리하기
문제점: 지금은 플레이북 파일 안에 변수가 섞여있어, 나중에 변수만 바꾸고 싶을 때도 플레이북 전체를 봐야 합니다.
해결책: group_vars라는 특별한 폴더를 만들어 변수들을 역할별로 분리합니다.

mkdir group_vars
vi group_vars/dbservers.yml

```
---
db_root_password: "MySecurePassword123"
db_name: "my_database"
```

### 2. ansible-vault로 비밀번호 암호화하기
문제점: group_vars에 비밀번호를 그대로 적어두면, 이 코드를 GitHub에 올렸을 때 비밀번호가 그대로 노출됩니다.
해결책: ansible-vault를 사용해 민감한 정보가 담긴 파일 자체를 암호화합니다.

ansible-vault create group_vars/dbservers/vault.yml

db_root_password: "MySecurePassword123"
db_name: "my_database"


ansible-playbook -i hosts site.yml --ask-vault-pass


3단계: 실행 및 확인
이제 작성한 작업 지시서를 실행하고, 각 서버가 제 역할을 하는지 확인합니다

## 1. 플레이북을 실행합니다
ansible-playbook -i hosts site.yml

## 2. 웹 서버(an-ksh001)가 잘 설치되었는지 확인합니다.
## 제어 노드 자신에게 설치했으므로, 바로 curl 명령을 실행합니다.
curl http://10.10.8.200

해결방안
창고' 역할을 하는 sites-available 디렉터리에는 아마 기본 설정 파일이 있을 겁니다. 이 파일을 '진열대' 역할을 하는 sites-enabled 디렉터리로 연결(심볼릭 링크)해주면 됩니다.
sudo ln -s /etc/nginx/sites-available/default /etc/nginx/sites-enabled/default

## 3. 데이터베이스 서버(an-ksh002)에 MariaDB가 잘 실행 중인지 확인합니다.
ansible an-ksh002 -m shell -a "systemctl is-active mariadb"


웹 서비스 확인 (HAProxy → Nginx)
로드 밸런서(an-ksh001)로 접속해서 트래픽이 웹 서버(an-ksh002, an-ksh003)로 잘 분산되는지 확인합니다.
curl http://10.10.8.200


모니터링 데이터 수집 확인 (Prometheus)
웹 브라우저에서 Prometheus UI에 접속하여 모든 서버의 정보를 잘 수집하고 있는지 확인합니다.
주소: http://10.10.8.204:9090
접속 후 상단 메뉴의 Status → Targets 로 이동했을 때, 인벤토리에 있는 모든 서버(an-ksh001 ~ an-ksh005) 목록이 초록색 UP 상태로 보이면 성공입니다.

모니터링 대시보드 확인 (Grafana)
웹 브라우저에서 Grafana UI에 접속하여 수집된 정보를 시각적으로 확인합니다.
주소: http://10.10.8.204:3000
(최초 접속 시 ID/PW: admin / admin)
로그인 후 대시보드(Dashboards) 메뉴로 이동하면, 모든 서버의 CPU, 메모리, 디스크 사용량 등을 그래프로 보여주는 화면을 볼 수 있습니다.
