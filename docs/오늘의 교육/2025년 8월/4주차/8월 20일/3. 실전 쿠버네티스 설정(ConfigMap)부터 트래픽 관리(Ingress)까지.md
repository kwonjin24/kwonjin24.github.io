---
layout: default
title: 실전 쿠버네티스: 설정(ConfigMap)부터 트래픽 관리(Ingress)까지


parent: 8월 20일
nav_order: 4
---

# 2025년 8월 20일 교육 내용

# 쿠버네티스


## 📌 쿠버네티스 ConfigMap 완벽 정리 (최종 통합본)
1. ConfigMap이란 무엇인가?
ConfigMap(컨피그맵)은 애플리케이션의 설정 데이터를 Pod와 분리하여 관리하기 위한 쿠버네티스 오브젝트입니다. 설정 데이터를 코드나 컨테이너 이미지에 포함시키지 않고, 필요할 때마다 외부에서 주입하는 방식을 가능하게 합니다.

        👉 쉬운 비유: 게임기의 설정 파일
        게임기 본체(Pod)와 게임 타이틀(컨테이너 이미지)이 있습니다. 이때 게임의 난이도나 언어 설정(설정 데이터)을 게임 타이틀 안에 저장하는 대신, 별도의 **설정 파일(ConfigMap)**로 만들어두면, 같은 게임 타이틀을 가지고도 설정을 바꾸며 여러 방식으로 즐길 수 있습니다.

2. ConfigMap을 왜 사용해야 하는가?
        환경별 설정 분리: 동일한 애플리케이션 이미지를 가지고도 개발(dev), 운영(production) 환경에 따라 다른 데이터베이스 주소나 설정을 쉽게 적용할 수 있습니다.

        이식성 및 재사용성 향상: 설정이 분리되어 있으므로, 컨테이너 이미지는 어떤 환경에서든 재사용할 수 있게 되어 이식성이 높아집니다.

        간편한 설정 관리: 여러 Pod가 동일한 설정을 공유할 때, ConfigMap 하나만 수정하면 모든 Pod에 변경 사항을 쉽게 반영할 수 있습니다.

        ### ⚠️ 중요: 민감 정보는 절대 금물
        ConfigMap은 암호화되지 않은 일반 텍스트(Plain Text) 데이터를 다룹니다. 데이터베이스 암호, API 키와 같은 민감한 정보는 반드시 시크릿(Secret)을 사용해야 합니다.

3. ConfigMap 생성 및 관리 방법
ConfigMap을 생성하는 방법은 크게 두 가지입니다.

1) 명령형(Imperative) 방식: kubectl create
실습이나 간단한 테스트 시, 명령어를 통해 빠르게 생성할 때 유용합니다.

리터럴(Literal) 값으로 생성:
Bash
```
$ kubectl create configmap my-config --from-literal=key1=value1 --from-literal=key2=value2
```

파일 기반으로 생성:

Bash
```
# redis.conf 파일의 내용을 key로 하는 컨피그맵 생성
kubectl create configmap redis-config --from-file=./redis.conf
```

2) 선언형(Declarative) 방식: YAML 파일 (실무 표준)
실무에서는 버전 관리(GitOps)를 위해 대부분 YAML 파일을 사용합니다.

vi game-demo-configmap.yaml
YAML
```
apiVersion: v1
kind: ConfigMap
metadata:
  name: game-demo
data:
  # 1. 단순 Key-Value 형태
  player_initial_lives: "3"

  # 2. 파일 내용을 값으로 사용하는 형태
  game.properties: |
    enemy.types=aliens,monsters
    player.maximum-lives=5
```

생성 및 수정:
Bash
```
kubectl apply -f game-demo-configmap.yaml
```

4. Pod에서 ConfigMap을 사용하는 3가지 방법
방법 1: 환경 변수(Environment Variables)로 주입
ConfigMap의 key-value를 컨테이너의 환경 변수로 주입합니다.

장점: 사용하기 매우 간편합니다.
단점: ConfigMap이 변경되어도, Pod를 재시작해야만 변경된 값이 반영됩니다.

방법 2: 볼륨 마운트(Volume Mount)로 주입
ConfigMap을 읽기 전용 볼륨으로 컨테이너 내부의 특정 경로에 파일 형태로 마운트합니다. data 필드의 각 key는 파일 이름이 되고, value는 파일 내용이 됩니다.

장점: ConfigMap이 변경되면, 마운트된 파일의 내용도 자동으로 업데이트됩니다.

YAML
```
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: mypod-container
    image: redis
    volumeMounts:
      - name: config-volume
        mountPath: "/etc/config" # 컨테이너 내부의 이 경로에 마운트
  volumes:
    - name: config-volume
      configMap:
        name: game-demo # 'game-demo' ConfigMap을 사용
```
        이 경우, /etc/config 디렉터리 안에는 player_initial_lives, game.properties 파일이 생성됩니다.

방법 3: 커맨드 라인 인자(Command-line Arguments)로 주입
컨테이너가 시작될 때 실행되는 커맨드의 인자로 ConfigMap 값을 전달하는 방식입니다.

5. 심화 개념 및 실무 Best Practices
업데이트 동작 방식:

        볼륨 마운트: ConfigMap 변경 시 자동 업데이트 (단, subPath로 마운트 시 업데이트 안 됨)

        환경 변수: ConfigMap 변경 시 자동 업데이트 안 됨 (Pod 재시작 필요)

불변(Immutable) ConfigMap:
YAML에 immutable: true를 설정하면, 생성된 ConfigMap을 수정할 수 없게 만듭니다. 운영 환경에서 실수로 인한 변경을 방지하고 클러스터 성능을 향상시키는 효과가 있습니다.

제약 사항:

        1MiB 크기 제한: ConfigMap의 데이터는 1MiB를 초과할 수 없습니다. 크기가 큰 설정 파일은 PVC나 외부 설정 관리 도구 사용을 권장합니다.

        etcd 부하: ConfigMap은 etcd에 저장되므로, 너무 많거나 크면 클러스터 성능에 영향을 줄 수 있습니다.

실무 적용 패턴:

        버전 관리: app-config-v1, app-config-v2처럼 ConfigMap 이름에 버전을 붙이면 롤백 관리가 용이합니다.

        변경 시 자동 재배포: 애플리케이션이 설정 변경을 자동으로 감지하지 못하는 경우, 아래와 같이 Deployment의 annotations에 ConfigMap의 해시(hash)값을 넣어, ConfigMap이 변경될 때마다 Pod가 자동으로 재시작되도록 유도할 수 있습니다.

vi Deployment YAML
YAML
```
...
template:
  metadata:
    annotations:
      checksum/config: "a1b2c3d4..." # ConfigMap 내용의 해시값을 수동/자동으로 주입
...
```

Helm Chart 활용: Helm을 사용하면 values.yaml 파일로 환경별 설정을 쉽게 관리하고, 이를 바탕으로 Chart가 ConfigMap을 동적으로 생성하도록 구성할 수 있어 매우 효율적입니다.

--------------------------------------------------------------------------

## 🚀 인그레스(Ingress) 규칙 적용 실습
#### 🎯 목표: 두 개의 웹 애플리케이션을 배포한 후, 단일 인그레스 규칙을 이용해 URL 경로(example.com/apple, example.com/banana)에 따라 각기 다른 애플리케이션으로 트래픽을 라우팅하는 방법을 배웁니다. 이 실습은 경로 기반 라우팅(Path-Based Routing) 기능을 중심으로 진행합니다.

💡 인그레스의 핵심 개념
인그레스는 쿠버네티스 클러스터 내부 서비스로 들어오는 외부 트래픽을 관리하는 API 오브젝트입니다. 여러 서비스에 대한 **단일 진입점(Single Entry Point)**을 제공하여 트래픽을 효율적으로 분산시키는 '스마트 라우터' 역할을 합니다.

인그레스 컨트롤러: 외부와 연결되는 유일한 통로.

서비스: 클러스터 내부의 개별 애플리케이션.

인그레스 규칙: 인그레스 컨트롤러가 트래픽을 어떻게 라우팅할지 정의하는 안내판.

사전 준비
이 실습을 진행하려면 클러스터에 NGINX 인그레스 컨트롤러가 반드시 설치되어 있어야 합니다. 설치 여부를 아래 명령어로 확인하세요.

Bash
```
# NGINX Ingress Controller 파드가 Running 상태인지 확인
kubectl get pods -n ingress-nginx
```

Minikube 환경에서는 다음 명령어로 인그레스 기능을 쉽게 활성화할 수 있습니다.
Bash
```
minikube addons enable ingress
```

또한, 실무 환경을 재현하기 위해 로컬 PC의 hosts 파일에 example.com 도메인을 워커 노드 IP에 매핑해 두는 것을 권장합니다.
Bash
```
# hosts 파일에 워커 노드 IP와 도메인 매핑 추가
echo "<WORKER_NODE_IP> example.com" | sudo tee -a /etc/hosts
```

1단계: 실습용 네임스페이스 생성
실습 리소스를 격리하기 위해 별도의 네임스페이스를 생성합니다.
Bash
```
kubectl create ns ingress-demo
kubectl config set-context --current --namespace=ingress-demo
```

2단계: 애플리케이션 배포 및 확인
apple-app.yaml과 banana-app.yaml 파일을 생성하고 다음 명령어를 실행하여 애플리케이션을 배포합니다.

vi apple-app.yaml 
Bash
```
apiVersion: apps/v1
kind: Deployment
...
---
apiVersion: v1
kind: Service
...

```

# banana-app.yaml 파일 내용 (이전과 동일)
apiVersion: apps/v1
kind: Deployment
...
---
apiVersion: v1
kind: Service
...

kubectl apply -f apple-app.yaml
kubectl apply -f banana-app.yaml

# 잠시 후 아래 명령어로 파드와 서비스 상태 확인
kubectl get pods,svc
3단계: 인그레스 규칙(Routing Rule) 생성
이제 URL 경로에 따라 트래픽을 분기시킬 인그레스 규칙을 정의합니다. example-ingress.yaml 파일을 생성하고 아래 내용을 저장하세요.

YAML

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-ingress
spec:
  ingressClassName: "nginx"
  rules:
  - host: example.com
    http:
      paths:
      - path: /apple
        pathType: Prefix
        backend:
          service:
            name: apple-service
            port:
              number: 80
      - path: /banana
        pathType: Prefix
        backend:
          service:
            name: banana-service
            port:
              number: 80
pathType: Prefix: 이 경로는 /apple로 시작하는 모든 요청(예: /apple/, /apple/juice)을 apple-service로 라우팅합니다.

4단계: 인그레스 규칙 적용 및 확인
생성한 인그레스 규칙을 클러스터에 적용하고, 규칙이 잘 생성되었는지 확인합니다.

Bash

kubectl apply -f example-ingress.yaml

# 인그레스 규칙이 생성되었는지 확인
kubectl get ingress
5단계: 최종 테스트 (도메인 기반 접근)
hosts 파일에 매핑해둔 example.com 도메인과 정의한 경로를 조합하여 각 애플리케이션에 정상적으로 접근되는지 curl 명령어로 확인합니다.

Bash

# /apple 경로로 요청 보내기 (apple-service 응답 확인)
curl http://example.com/apple

# 예상 결과
# This is APPLE service

# /banana 경로로 요청 보내기 (banana-service 응답 확인)
curl http://example.com/banana

# 예상 결과
# This is BANANA service
6단계: 추가 실습 아이디어 (심화)
루트 경로(/) 라우팅: Ingress 규칙에 path: /를 추가하여 루트 경로로 들어오는 요청을 특정 기본 서비스(예: apple-service)로 연결해보세요.

애노테이션을 활용한 기능 확장: NGINX Ingress Controller는 애노테이션을 통해 rewrite-target 등 다양한 고급 기능을 제공합니다.

nginx.ingress.kubernetes.io/rewrite-target: / 애노테이션을 사용해 URL 경로를 재작성하는 실습을 해보세요.

HPA와 결합: HPA(Horizontal Pod Autoscaler)를 apple-deployment에 적용하고, curl 요청을 지속적으로 보내면서 파드 개수가 자동으로 늘어나는 것을 확인해보세요.

7단계: 실습 리소스 전체 삭제
실습이 끝나면 생성했던 모든 리소스를 삭제합니다.

Bash

kubectl delete -f example-ingress.yaml
kubectl delete -f apple-app.yaml
kubectl delete -f banana-app.yaml
kubectl delete ns ingress-demo

--------------------------------------------------------------------------

🚀 애플리케이션에 환경 변수(env) 전달하기 실습 (최종 완성본)
🎯 목표: Deployment YAML 파일 내에 직접 환경 변수(env)를 정의하여, 컨테이너가 시작될 때 필요한 설정값(데이터베이스 비밀번호, 이름 등)을 전달하는 방법을 실습합니다.

💡 핵심 개념:

환경 변수 주입: spec.containers.env 필드를 사용하면 컨테이너에 필요한 설정값을 간단하게 전달할 수 있습니다.

설정의 분리: 이 방식은 설정값을 컨테이너 이미지 자체에 포함시키는 대신, 배포 시점에 외부에서 주입하므로 이미지의 재사용성을 높이는 첫걸음입니다.

⚠️ 중요: 이 실습에서는 학습 편의를 위해 비밀번호를 YAML 파일에 직접 작성하지만, 실제 운영 환경(Production)에서는 절대 이렇게 사용하면 안 됩니다. 비밀번호와 같은 민감 정보는 반드시 시크릿(Secret) 리소스를 통해 안전하게 관리해야 합니다.

단계별 실습
1단계: 실습 환경 준비
실습에 사용할 YAML 파일을 저장할 디렉토리를 생성합니다.

Bash

$ mkdir -p configmap-lab && cd configmap-lab
2단계: Deployment YAML 파일 작성
MariaDB 컨테이너를 실행하고, 초기 루트 비밀번호와 데이터베이스 이름을 환경 변수로 설정하는 Deployment를 정의합니다.

mysql-env-deployment.yaml 파일을 생성하세요. (이름을 더 명확하게 변경)

YAML

# mysql-env-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-env-deploy # 리소스 이름 변경
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mariadb:10.7
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "dkagh1."
        - name: MYSQL_DATABASE
          value: "kubernetes"
        ports:
        - containerPort: 3306
3단계: Deployment 생성 및 Pod 준비 상태 확인
작성한 YAML 파일을 클러스터에 적용하고, Pod가 단순히 Running 상태를 넘어 실제 접속 가능한 Ready 상태가 될 때까지 기다립니다.

Bash

$ kubectl apply -f mysql-env-deployment.yaml
Bash

# Pod가 Ready 상태가 될 때까지 최대 120초간 대기합니다.
$ kubectl wait --for=condition=Ready pod -l app=mysql --timeout=120s
출력 예상: pod/mysql-xxxx-yyyy condition met

4단계: 컨테이너 내부 환경 변수 확인
exec 명령으로 실행 중인 컨테이너 내부에 접속하여, 환경 변수가 올바르게 설정되었는지 직접 확인합니다.

Bash

# deployment/mysql-env-deploy 내부의 컨테이너에 접속
$ kubectl exec -it deployment/mysql-env-deploy -- /bin/bash

# --- 컨테이너 내부 쉘에서 실행 ---
root@mysql-xxxx:/# echo $MYSQL_ROOT_PASSWORD
출력 예상: dkagh1.

5단계: 데이터베이스 접속 및 동작 확인
설정된 비밀번호로 데이터베이스에 접속하여 정상적으로 동작하는지 확인합니다.

Bash

# --- 컨테이너 내부 쉘에서 계속 실행 ---
# 루트 유저로 접속 시도
root@mysql-xxxx:/# mysql -uroot -p

# 비밀번호 입력: dkagh1.
Enter password:

# 접속 성공 후, 기본 데이터베이스 목록 확인
MariaDB [(none)]> show databases;
출력 예상: kubernetes 데이터베이스가 목록에 보이는 것을 확인할 수 있습니다.

데이터베이스 확인이 끝났으면 exit를 입력하여 mysql과 컨테이너 쉘에서 차례로 빠져나옵니다.

6단계: 실습 리소스 정리
실습이 끝나면 생성했던 Deployment를 삭제하여 환경을 정리합니다.

Bash

$ kubectl delete -f mysql-env-deployment.yaml
💡 다음 학습으로 연결: 이번 실습에서는 환경 변수를 YAML에 직접 넣었지만, 이것은 설정과 애플리케이션이 완전히 분리된 것이 아닙니다. 다음 단계에서는 ConfigMap과 Secret을 사용하여 이 설정값들을 별도의 리소스로 분리하고 관리하는 더 발전된 방법을 배웁니다.

--------------------------------------------------------------------------

🚀 ConfigMap 실습: envFrom으로 설정값 전체 주입하기 (최종 완성본)
🎯 목표: 설정 데이터를 별도의 ConfigMap 리소스에 정의하고, envFrom을 사용하여 해당 ConfigMap의 모든 키-값 쌍을 컨테이너에 환경 변수로 한 번에 주입하는 방법을 실습합니다.

💡 핵심 개념:

envFrom: env를 사용하여 환경 변수를 하나씩 정의하는 대신, envFrom을 사용하면 ConfigMap(또는 Secret)에 있는 모든 데이터를 컨테이너의 환경 변수로 가져올 수 있습니다.

설정의 완전한 분리: 이 방식을 사용하면 Deployment YAML은 어떤 설정값이 있는지 알 필요 없이, 어떤 ConfigMap을 사용할지만 지정하면 됩니다.

⚠️ 중요: 이 실습에서도 학습 편의를 위해 비밀번호를 ConfigMap에 작성하지만, 실제 운영 환경에서는 반드시 시크릿(Secret) 리소스를 사용해야 합니다.

단계별 실습
1단계: ConfigMap YAML 파일 작성
먼저, MariaDB 컨테이너에 필요한 환경 변수들을 key-value 형태로 정의하는 ConfigMap을 만듭니다.

mysql-configmap.yaml 파일을 생성하세요.

YAML

# mysql-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_ROOT_PASSWORD: "dkagh1."
  MYSQL_DATABASE: "kubernetes"
2단계: Deployment YAML 파일 작성
envFrom을 사용하여 위에서 만든 mysql-config ConfigMap을 참조하도록 Deployment를 정의합니다.

mysql-cm-deployment.yaml 파일을 생성하세요. (비교를 위해 이름 일관성 유지)

YAML

# mysql-cm-deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-cm-deploy # 이전 실습과 비교를 위한 명확한 이름
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mariadb:10.7
        envFrom:
        - configMapRef:
            name: mysql-config
        ports:
        - containerPort: 3306
3단계: 리소스 생성 및 상태 확인
작성한 ConfigMap과 Deployment를 순서대로 클러스터에 적용합니다.

Bash

# 1. ConfigMap 생성
$ kubectl apply -f mysql-configmap.yaml

# 2. Deployment 생성
$ kubectl apply -f mysql-cm-deployment.yaml
생성된 리소스들의 상태를 확인합니다.

Bash

# ConfigMap에 데이터가 잘 들어갔는지 확인
$ kubectl describe configmap mysql-config

# Pod가 정상적으로 생성되고 있는지 확인
$ kubectl get pod -l app=mysql -o wide

# Pod가 실제 접속 가능한 Ready 상태가 될 때까지 대기
$ kubectl wait --for=condition=Ready pod -l app=mysql --timeout=120s
4단계: 컨테이너 내부 환경 변수 확인
컨테이너에 접속하여 envFrom을 통해 ConfigMap의 모든 데이터가 환경 변수로 주입되었는지 확인합니다.

Bash

# deployment/mysql-cm-deploy 내부의 컨테이너에 접속
$ kubectl exec -it deployment/mysql-cm-deploy -- /bin/bash

# --- 컨테이너 내부 쉘에서 실행 ---
# 'MYSQL'이 포함된 모든 환경 변수 출력
root@mysql-xxxx:/# printenv | grep MYSQL
출력 예상:

MYSQL_ROOT_PASSWORD=dkagh1.
MYSQL_DATABASE=kubernetes
5단계: 데이터베이스 접속 및 동작 확인
주입된 환경 변수를 사용하여 데이터베이스가 정상적으로 설정되었는지 최종 확인합니다.

Bash

# --- 컨테이너 내부 쉘에서 계속 실행 ---
# 루트 유저로 접속
root@mysql-xxxx:/# mysql -uroot -p"$MYSQL_ROOT_PASSWORD"

# 접속 성공 후, 데이터베이스 목록 확인
MariaDB [(none)]> show databases;
출력 예상: kubernetes 데이터베이스가 목록에 보이는 것을 확인할 수 있습니다.

exit를 입력하여 mysql과 컨테이너 쉘에서 차례로 빠져나옵니다.

6단계: 실습 리소스 정리
실습이 끝나면 생성했던 모든 리소스를 삭제합니다. 일반적으로 ConfigMap에 의존하는 Deployment를 먼저 삭제하는 것이 깔끔한 정리 순서입니다.

Bash

$ kubectl delete -f mysql-cm-deployment.yaml
$ kubectl delete -f mysql-configmap.yaml

--------------------------------------------------------------------------

🚀 ConfigMap 실습: valueFrom으로 특정 설정값 선택하여 주입하기
🎯 목표: ConfigMap에 정의된 여러 설정값 중, 필요한 특정 키(key)만 선택하여 컨테이너에 환경 변수로 주입하는 valueFrom 사용법을 실습합니다.

💡 핵심 개념:

envFrom vs valueFrom:

envFrom (이전 실습): ConfigMap의 모든 키-값 쌍을 한 번에 주입합니다. 간편하지만 유연성이 떨어집니다.

valueFrom (이번 실습): env 섹션에서 환경 변수를 하나씩 정의하되, 그 값을 ConfigMap의 특정 키에서 가져옵니다. 더 세밀한 제어가 가능합니다.

사용 시나리오:

하나의 큰 ConfigMap에서 일부 값만 필요할 때

ConfigMap의 키 이름(MYSQL_PASSWORD)과 컨테이너에서 사용할 환경 변수 이름(DB_PASS)을 다르게 매핑하고 싶을 때

⚠️ 중요: 이 실습에서도 학습 편의를 위해 비밀번호를 ConfigMap에 작성하지만, 실제 운영 환경에서는 반드시 시크릿(Secret) 리소스를 사용해야 합니다.

단계별 실습
1단계: ConfigMap YAML 파일 작성
이전 실습과 동일한 내용의 ConfigMap을 사용합니다.

mysql-config.yaml 파일을 생성하세요.

YAML

# mysql-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_ROOT_PASSWORD: "dkagh1."
  MYSQL_DATABASE: "kubernetes"
2단계: Deployment YAML 파일 작성
env와 valueFrom을 사용하여 위에서 만든 mysql-config ConfigMap의 각 키를 개별적으로 참조하도록 Deployment를 정의합니다.

mysql-deploy-valuefrom.yaml 파일을 생성하세요.

YAML

# mysql-deploy-valuefrom.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-vf-deploy # valueFrom을 의미하는 vf 추가
spec:
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mariadb:10.7
        # env를 사용하여 환경 변수를 개별적으로 정의
        env:
        - name: MYSQL_ROOT_PASSWORD # 컨테이너에서 사용할 환경 변수 이름
          valueFrom:
            configMapKeyRef:
              name: mysql-config # 사용할 ConfigMap 이름
              key: MYSQL_ROOT_PASSWORD # 위 ConfigMap에서 가져올 키
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: mysql-config
              key: MYSQL_DATABASE
        ports:
        - containerPort: 3306
3단계: 리소스 생성 및 확인
작성한 ConfigMap과 Deployment를 순서대로 클러스터에 적용합니다.

Bash

# 1. ConfigMap 생성
$ kubectl apply -f mysql-config.yaml

# 2. Deployment 생성
$ kubectl apply -f mysql-deploy-valuefrom.yaml
Pod가 Ready 상태가 될 때까지 기다립니다.

Bash

# Pod가 Ready 상태가 될 때까지 대기
$ kubectl wait --for=condition=Ready pod -l app=mysql --timeout=120s
4단계: 컨테이너 내부 환경 변수 확인
컨테이너에 접속하여 valueFrom을 통해 ConfigMap의 각 데이터가 환경 변수로 잘 주입되었는지 확인합니다.

Bash

# deployment/mysql-vf-deploy 내부의 컨테이너에 접속
$ kubectl exec -it deployment/mysql-vf-deploy -- /bin/bash

# --- 컨테이너 내부 쉘에서 실행 ---
# 'MYSQL'이 포함된 모든 환경 변수 출력
root@mysql-xxxx:/# printenv | grep MYSQL
출력 예상:

MYSQL_ROOT_PASSWORD=dkagh1.
MYSQL_DATABASE=kubernetes
5단계: 데이터베이스 접속 및 동작 확인
주입된 환경 변수를 사용하여 데이터베이스가 정상적으로 설정되었는지 최종 확인합니다.

Bash

# --- 컨테이너 내부 쉘에서 계속 실행 ---
# 루트 유저로 접속
root@mysql-xxxx:/# mysql -uroot -p"$MYSQL_ROOT_PASSWORD"

# 접속 성공 후, 데이터베이스 목록 확인
MariaDB [(none)]> show databases;
출력 예상: kubernetes 데이터베이스가 목록에 보이는 것을 확인할 수 있습니다.

exit를 입력하여 mysql과 컨테이너 쉘에서 차례로 빠져나옵니다.

6단계: 실습 리소스 정리
실습이 끝나면 생성했던 모든 리소스를 삭제합니다.

Bash

$ kubectl delete -f mysql-deploy-valuefrom.yaml
$ kubectl delete -f mysql-config.yaml

--------------------------------------------------------------------------

🚀 ConfigMap 실습: 설정을 파일로 마운트하기 (Volume Mount)
🎯 목표: ConfigMap에 저장된 설정 데이터를 컨테이너 내부의 특정 경로에 파일 형태로 마운트(mount)하는 방법을 실습합니다. 또한, 이 방식의 가장 큰 장점인 설정 자동 업데이트 기능을 직접 확인합니다.

💡 핵심 개념:

volumes & volumeMounts:

Pod의 .spec.volumes 필드에 사용할 볼륨을 정의하고, 어떤 ConfigMap을 사용할지 지정합니다.

컨테이너의 .spec.containers.volumeMounts 필드에 위에서 정의한 볼륨을 어느 경로(mountPath)에 연결할지 지정합니다.

Key → 파일, Value → 내용: ConfigMap의 data 필드에 있는 각 키(key)는 파일 이름이 되고, 값(value)은 해당 파일의 내용이 되어 마운트됩니다.

자동 업데이트: 이 방식으로 마운트된 파일은, 원본 ConfigMap이 변경되면 Pod를 재시작하지 않아도 내용이 자동으로 업데이트됩니다.

사용 방식	장점	단점
환경 변수	간편함	Pod 재시작 전까지 업데이트 안 됨
볼륨 마운트	자동 업데이트 가능	애플리케이션이 파일에서 설정을 읽어야 함
단계별 실습
1단계: ConfigMap YAML 파일 작성
실습에 사용할 ConfigMap을 정의합니다. 이전 실습과 동일한 내용입니다.

mysql-config.yaml 파일을 생성하세요.

YAML

# mysql-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  MYSQL_ROOT_PASSWORD: "dkagh1."
  MYSQL_DATABASE: "kubernetes"
2단계: Deployment YAML 파일 작성
ConfigMap을 볼륨으로 마운트하는 Deployment를 정의합니다.

mysql-deploy-volume.yaml 파일을 생성하세요.

YAML

# mysql-deploy-volume.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-vol-deploy
spec:
  selector:
    matchLabels:
      app: mysql-vol
  template:
    metadata:
      labels:
        app: mysql-vol
    spec:
      containers:
      - name: mysql
        image: mariadb:10.7
        # envFrom을 사용하지 않고, 컨테이너 시작 후 마운트된 파일을 통해 설정 확인
        env:
        - name: MYSQL_ROOT_PASSWORD
          value: "dkagh1." # DB 접속을 위해 임시로 변수 사용
        ports:
        - containerPort: 3306
        # 2. 컨테이너의 /tmp/config 경로에 'mysql-config-vol' 볼륨을 마운트
        volumeMounts:
        - name: mysql-config-vol
          mountPath: /tmp/config
      # 1. 'mysql-config-vol'라는 이름의 볼륨을 정의하고,
      #    'mysql-config' ConfigMap을 소스로 사용
      volumes:
      - name: mysql-config-vol
        configMap:
          name: mysql-config
3단계: 리소스 생성 및 확인
작성한 YAML 파일들을 클러스터에 적용합니다.

Bash

$ kubectl apply -f mysql-config.yaml
$ kubectl apply -f mysql-deploy-volume.yaml
Pod가 Ready 상태가 될 때까지 기다립니다.

Bash

$ kubectl wait --for=condition=Ready pod -l app=mysql-vol --timeout=120s
4단계: 마운트된 볼륨(파일) 확인
컨테이너에 접속하여 ConfigMap의 데이터가 파일로 잘 생성되었는지 확인합니다.

Bash

$ kubectl exec -it deployment/mysql-vol-deploy -- /bin/bash

# --- 컨테이너 내부 쉘에서 실행 ---

# 1. 마운트 경로로 이동
root@mysql-xxxx:/# cd /tmp/config

# 2. 파일 목록 확인
root@mysql-xxxx:/tmp/config# ls -l
# 예상 결과:
# total 8
# ..data -> ..2025_08_20_21_51_36.123456789
# MYSQL_DATABASE -> ..data/MYSQL_DATABASE
# MYSQL_ROOT_PASSWORD -> ..data/MYSQL_ROOT_PASSWORD

# 3. 각 파일의 내용 확인
root@mysql-xxxx:/tmp/config# cat MYSQL_DATABASE
# 예상 결과: kubernetes
root@mysql-xxxx:/tmp/config# cat MYSQL_ROOT_PASSWORD
# 예상 결과: dkagh1.
결과: ConfigMap의 키(MYSQL_DATABASE, MYSQL_ROOT_PASSWORD)가 파일 이름으로, 값이 파일 내용으로 마운트된 것을 확인할 수 있습니다.

5단계: 설정 자동 업데이트 확인 (핵심)
이제 Pod를 재시작하지 않고 ConfigMap을 변경했을 때, 마운트된 파일 내용이 자동으로 바뀌는지 확인해 봅시다.

(다른 터미널에서) 로컬의 mysql-config.yaml 파일을 수정하고 다시 적용합니다.

YAML

# mysql-config.yaml (수정)
...
data:
  MYSQL_ROOT_PASSWORD: "dkagh1."
  MYSQL_DATABASE: "new_database" # <-- 값 변경
Bash

$ kubectl apply -f mysql-config.yaml
컨테이너 내부에서 다시 파일 내용 확인:
이전에 접속했던 컨테이너 쉘에서 (재접속할 필요 없이) 다시 파일 내용을 확인합니다.

Bash

# --- 컨테이너 내부 쉘에서 계속 실행 ---
# 잠시 (최대 1분) 기다린 후, 파일 내용을 다시 확인
root@mysql-xxxx:/tmp/config# cat MYSQL_DATABASE
결과: new_database
Pod를 재시작하지 않았음에도 불구하고 파일 내용이 변경된 것을 확인할 수 있습니다.

exit를 눌러 컨테이너 쉘에서 빠져나옵니다.

6단계: 실습 리소스 정리
Bash

$ kubectl delete -f mysql-deploy-volume.yaml
$ kubectl delete -f mysql-config.yaml

--------------------------------------------------------------------------

## kubectl create configmap 명령어 활용법

## 방법 1: --from-literal 로 직접 값 지정하기 (5번째 실습)
이것은 "글자 그대로(literal)" 키와 값을 직접 터미널에 입력하여 ConfigMap을 만드는 방식입니다.

실행한 명령어:

Bash

$ kubectl create configmap mysql-config \
  --from-literal=MYSQL_ROOT_PASSWORD=dkagh1. \
  --from-literal=MYSQL_DATABASE=kubernetes
결과:
mysql-config라는 이름의 ConfigMap이 생성되고, 그 안에는 다음과 같이 두 개의 데이터가 들어갑니다.

ConfigMap: mysql-config
└── data:
    ├── MYSQL_ROOT_PASSWORD: "dkagh1."
    └── MYSQL_DATABASE: "kubernetes"
용도: 간단한 키-값 한두 개를 테스트용으로 빠르게 만들 때 매우 편리합니다.

## 방법 2: --from-file 로 파일에서 값 가져오기 (6번째 실습)
이것은 "파일로부터(from file)" ConfigMap을 만드는 방식으로, 지정한 파일의 이름과 내용 전체를 사용합니다.

실행한 명령어:

Bash

# 1. 내용을 담은 파일 생성
$ cat > mysql.txt <<EOF
MYSQL_ROOT_PASSWORD=dkagh1.
MYSQL_DATABASE=kubernetes
EOF

# 2. 파일을 이용하여 ConfigMap 생성
$ kubectl create configmap mysql-config --from-file=mysql.txt
결과:
mysql-config라는 이름의 ConfigMap이 생성되고, 그 안에는 다음과 같이 파일 이름이 key가 되고, 파일 내용 전체가 value가 되는 데이터가 하나 들어갑니다.

ConfigMap: mysql-config
└── data:
    └── mysql.txt: |
          MYSQL_ROOT_PASSWORD=dkagh1.
          MYSQL_DATABASE=kubernetes
용도: 이미 nginx.conf, .properties처럼 완성된 설정 파일이 있을 때, 그 파일을 통째로 ConfigMap에 저장하고 싶을 때 사용합니다.

💡 심화 팁: 만약 mysql.txt 파일 안의 KEY=VALUE 형식 자체를 환경 변수처럼 사용하고 싶다면, --from-file이 아니라 --from-env-file 옵션을 사용해야 합니다.

--------------------------------------------------------------------------

🚀 ConfigMap 실습: 여러 ConfigMap에서 envFrom으로 설정값 가져오기
🎯 목표: 서로 다른 용도의 설정값이 담긴 여러 개의 ConfigMap을 생성하고, envFrom을 사용하여 이 모든 값을 하나의 컨테이너에 환경 변수로 주입하는 방법을 실습합니다.

💡 핵심 개념:

envFrom은 배열(Array): Deployment YAML에서 envFrom 필드는 여러 개의 소스를 가질 수 있는 배열입니다.

설정의 조합: configMapRef를 여러 개 나열하면, 쿠버네티스는 각 ConfigMap에 있는 모든 키-값 쌍을 모아 컨테이너의 환경 변수로 만들어 줍니다.

키 충돌 시: 만약 서로 다른 ConfigMap에 동일한 이름의 키가 있다면, YAML 파일에서 더 아래쪽에 정의된 ConfigMap의 값이 우선 적용됩니다.

단계별 실습
1단계: 여러 개의 ConfigMap 생성
실습에 사용할 두 개의 ConfigMap을 kubectl create 명령어로 빠르게 생성합니다. 하나는 로그 레벨 설정을, 다른 하나는 일반 정보를 담고 있습니다.

Bash

# 첫 번째 ConfigMap 생성
$ kubectl create configmap log-level-configmap --from-literal=LOG_LEVEL=DEBUG

# 두 번째 ConfigMap 생성
$ kubectl create configmap start-k8s --from-literal=k8s=kubernetes --from-literal=container=docker
2단계: Deployment YAML 파일 작성
envFrom 섹션에 위에서 만든 두 개의 ConfigMap을 모두 참조하도록 Deployment를 정의합니다.

httpd-deploy-multifrom.yaml 파일을 생성하세요.

YAML

# httpd-deploy-multifrom.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dp-web-apaches
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dp-web-apaches
  template:
    metadata:
      labels:
        app: dp-web-apaches
    spec:
      containers:
      - image: httpd:latest
        name: httpd
        ports:
        - containerPort: 80
        # envFrom은 배열이므로 여러 소스를 참조할 수 있습니다.
        envFrom:
        - configMapRef:
            name: log-level-configmap
        - configMapRef:
            name: start-k8s
3단계: 리소스 생성 및 확인
작성한 YAML 파일을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash

$ kubectl apply -f httpd-deploy-multifrom.yaml
$ kubectl wait --for=condition=Ready pod -l app=dp-web-apaches --timeout=120s
4단계: 컨테이너 내부 환경 변수 확인
컨테이너에 접속하여 두 ConfigMap의 모든 데이터가 환경 변수로 잘 주입되었는지 확인합니다.

Bash

# Pod 이름 가져오기
$ POD_NAME=$(kubectl get pods -l app=dp-web-apaches -o jsonpath='{.items[0].metadata.name}')

# 컨테이너의 모든 환경 변수 출력
$ kubectl exec $POD_NAME -- env
출력 예상:
출력된 환경 변수 목록에서 아래 3개의 변수가 모두 포함되어 있는지 확인하세요.

LOG_LEVEL=DEBUG
k8s=kubernetes
container=docker
... (기타 기본 환경 변수)
이 결과를 통해 두 ConfigMap의 내용이 성공적으로 조합되었음을 알 수 있습니다.

5단계: 실습 리소스 정리
실습이 끝나면 생성했던 모든 리소스를 삭제하여 환경을 정리합니다.

Bash

$ kubectl delete deployment dp-web-apaches
$ kubectl delete configmap log-level-configmap start-k8s

--------------------------------------------------------------------------

🚀 ConfigMap 실습: valueFrom으로 특정 설정값 선택 및 이름 변경하기
🎯 목표: ConfigMap에 있는 여러 데이터 중 필요한 키(key)만 선택하고, 컨테이너 내부에서 새로운 이름의 환경 변수로 주입하는 valueFrom 사용법을 실습합니다.

💡 핵심 개념:

valueFrom: env 섹션에서 환경 변수를 하나씩 정의하되, 그 값을 ConfigMap의 특정 키에서 가져옵니다. 이를 통해 필요한 데이터만 선별적으로 주입할 수 있습니다.

환경 변수 이름 변경: env.name 필드로 컨테이너 내부에서 사용할 변수 이름을 자유롭게 지정하고, configMapKeyRef.key로 원본 ConfigMap의 키를 지정하여 서로 다른 이름으로 매핑할 수 있습니다.

사용 방식	주입 대상	이름 변경
envFrom	ConfigMap의 모든 데이터	불가 (원본 키 이름 사용)
valueFrom	ConfigMap의 특정 키 하나	가능
단계별 실습
1단계: 여러 개의 ConfigMap 생성
실습에 사용할 두 개의 ConfigMap을 생성합니다. 이전 실습과 동일합니다.

Bash

# 첫 번째 ConfigMap 생성
$ kubectl create configmap log-level-configmap --from-literal=LOG_LEVEL=DEBUG

# 두 번째 ConfigMap 생성
$ kubectl create configmap start-k8s --from-literal=k8s=kubernetes --from-literal=container=docker
2단계: Deployment YAML 파일 작성
env와 valueFrom을 사용하여, 위에서 만든 ConfigMap들에서 필요한 키만 선택적으로 가져오도록 Deployment를 정의합니다.

httpd-deploy-valuefrom.yaml 파일을 생성하세요.

YAML

# httpd-deploy-valuefrom.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dp-web-apaches
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dp-web-apaches
  template:
    metadata:
      labels:
        app: dp-web-apaches
    spec:
      containers:
      - image: httpd:latest
        name: httpd
        ports:
        - containerPort: 80
        env:
          # log-level-configmap에서 LOG_LEVEL 키의 값을 가져와
          # ENV_KEYNAME_1 이라는 이름의 환경 변수로 주입
        - name: ENV_KEYNAME_1
          valueFrom:
            configMapKeyRef:
              name: log-level-configmap
              key: LOG_LEVEL
          # start-k8s configmap에서 k8s 키의 값을 가져와
          # ENV_KEYNAME_2 라는 이름의 환경 변수로 주입
        - name: ENV_KEYNAME_2
          valueFrom:
            configMapKeyRef:
              name: start-k8s
              key: k8s
3단계: 리소스 생성 및 확인
작성한 YAML 파일을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash

$ kubectl apply -f httpd-deploy-valuefrom.yaml
$ kubectl wait --for=condition=Ready pod -l app=dp-web-apaches --timeout=120s
4단계: 컨테이너 내부 환경 변수 확인
컨테이너에 접속하여, 우리가 선택하고 이름을 바꾼 환경 변수만 정확하게 주입되었는지 확인합니다.

Bash

# Pod 이름 가져오기
$ POD_NAME=$(kubectl get pods -l app=dp-web-apaches -o jsonpath='{.items[0].metadata.name}')

# 컨테이너의 모든 환경 변수 출력
$ kubectl exec $POD_NAME -- env
✨ 핵심 관찰 포인트:
출력된 환경 변수 목록에서 아래 내용을 확인하세요.

ENV_KEYNAME_1=DEBUG
ENV_KEYNAME_2=kubernetes
... (기타 기본 환경 변수)
원본 키 이름(LOG_LEVEL, k8s)이 아닌, **새로 지정한 이름(ENV_KEYNAME_1, ENV_KEYNAME_2)**으로 변수가 생성되었습니다.

start-k8s ConfigMap에 있던 container=docker는 선택하지 않았으므로 주입되지 않았습니다.

5단계: 실습 리소스 정리
실습이 끝나면 생성했던 모든 리소스를 삭제하여 환경을 정리합니다.

Bash

$ kubectl delete deployment dp-web-apaches
$ kubectl delete configmap log-level-configmap start-k8s

--------------------------------------------------------------------------

🚀 ConfigMap 실습: 설정을 파일로 마운트하기 (Volume Mount)
🎯 목표: ConfigMap에 저장된 설정 데이터를 컨테이너 내부의 특정 경로에 파일 형태로 마운트(mount)하는 방법을 실습하고, 이 방식의 장점인 설정 자동 업데이트 기능을 직접 확인합니다.

💡 핵심 개념:

volumes & volumeMounts:

Pod의 .spec.volumes 필드에 사용할 볼륨을 정의하고, 어떤 ConfigMap을 사용할지 지정합니다.

컨테이너의 .spec.containers.volumeMounts 필드에 위에서 정의한 볼륨을 어느 경로(mountPath)에 연결할지 지정합니다.

Key → 파일, Value → 내용: ConfigMap의 data 필드에 있는 각 키(key)는 파일 이름이 되고, 값(value)은 해당 파일의 내용이 되어 마운트됩니다.

단계별 실습
1단계: ConfigMap 생성
실습에 사용할 두 개의 ConfigMap을 생성합니다. 이 중 start-k8s ConfigMap을 마운트할 것입니다.

Bash

# 사용하지 않을 ConfigMap (비교용)
$ kubectl create configmap log-level-configmap --from-literal=LOG_LEVEL=DEBUG

# 볼륨으로 마운트할 ConfigMap
$ kubectl create configmap start-k8s --from-literal=k8s=kubernetes --from-literal=container=docker
2단계: Deployment YAML 파일 작성
start-k8s ConfigMap을 볼륨으로 마운트하는 Deployment를 정의합니다.

httpd-deploy-volume.yaml 파일을 생성하세요.

YAML

# httpd-deploy-volume.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dp-web-apaches
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dp-web-apaches
  template:
    metadata:
      labels:
        app: dp-web-apaches
    spec:
      # 1. 'configmap-volume'라는 이름의 볼륨을 정의하고,
      #    'start-k8s' ConfigMap을 소스로 사용
      volumes:
      - name: configmap-volume
        configMap:
          name: start-k8s
      containers:
      - image: httpd:latest
        name: httpd
        ports:
        - containerPort: 80
        # 2. 컨테이너의 /etc/config 경로에 'configmap-volume' 볼륨을 마운트
        volumeMounts:
        - name: configmap-volume
          mountPath: /etc/config
3단계: 리소스 생성 및 확인
작성한 YAML 파일을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash

$ kubectl apply -f httpd-deploy-volume.yaml
$ kubectl wait --for=condition=Ready pod -l app=dp-web-apaches --timeout=120s
4단계: 마운트된 볼륨(파일) 확인
컨테이너에 접속하여 ConfigMap의 데이터가 파일로 잘 생성되었는지 확인합니다.

Bash

# Pod 이름 가져오기
$ POD_NAME=$(kubectl get pods -l app=dp-web-apaches -o jsonpath='{.items[0].metadata.name}')

# /etc/config 디렉터리의 파일 목록 확인
$ kubectl exec $POD_NAME -- ls /etc/config
출력 예상: container와 k8s 라는 두 개의 파일이 보입니다.

Bash

# 각 파일의 내용 확인
$ kubectl exec $POD_NAME -- cat /etc/config/k8s
출력 예상: kubernetes

결과: ConfigMap의 키가 파일 이름으로, 값이 파일 내용으로 마운트된 것을 확인할 수 있습니다.

5단계: 설정 자동 업데이트 확인 (핵심)
Pod를 재시작하지 않고 ConfigMap을 변경했을 때, 마운트된 파일 내용이 자동으로 바뀌는지 확인해 봅시다.

(다른 터미널에서) start-k8s ConfigMap의 container 키 값을 podman으로 변경합니다.

Bash

$ kubectl patch configmap start-k8s --patch '{"data":{"container":"podman"}}'
컨테이너 내부에서 다시 파일 내용 확인:
잠시(최대 1분) 기다린 후, 이전에 접속했던 컨테이너에서 (재접속할 필요 없이) 다시 파일 내용을 확인합니다.

Bash

$ kubectl exec $POD_NAME -- cat /etc/config/container
출력 예상: podman
Pod를 재시작하지 않았음에도 불구하고 파일 내용이 변경된 것을 확인할 수 있습니다.

6단계: 실습 리소스 정리
Bash

$ kubectl delete deployment dp-web-apaches
$ kubectl delete configmap log-level-configmap start-k8s

--------------------------------------------------------------------------

🚀 ConfigMap 실습: items로 특정 설정만 파일로 마운트하기 (최종 완성본)
🎯 목표: ConfigMap에 있는 여러 데이터 중 필요한 키(key)만 선택하여 컨테이너 내부의 볼륨에 파일로 마운트하고, 파일 이름을 원하는 대로 변경하는 방법을 실습합니다.

💡 핵심 개념:

configMap.items: volumes를 정의할 때 items 필드를 사용하면, ConfigMap의 전체 데이터가 아닌 지정한 key에 해당하는 데이터만 파일로 만들 수 있습니다. 이를 통해 컨테이너에 불필요한 설정이 노출되는 것을 막고, 파일 이름을 자유롭게 변경할 수 있습니다.

환경 변수 vs 볼륨 마운트: 언제 무엇을 써야 할까?
기능	환경 변수 방식 (envFrom/valueFrom)	볼륨 마운트 방식 (volumeMounts)
데이터 형태	간단한 문자열 값	파일 (.conf, .xml, .properties 등)
자동 업데이트	❌ (Pod 재시작 필요)	✅ (자동 반영)
주요 용도	간단한 설정값(로그 레벨, 기능 플래그 등) 주입	애플리케이션 설정 파일 전체를 전달
단계별 실습
1단계: ConfigMap 생성
실습에 사용할 ConfigMap을 생성합니다.

Bash

# 볼륨으로 마운트할 ConfigMap
$ kubectl create configmap start-k8s --from-literal=k8s=kubernetes --from-literal=container=docker
2단계: Deployment YAML 파일 작성
items 필드를 사용하여 start-k8s ConfigMap의 모든 키를 각각 다른 파일 이름으로 마운트하도록 Deployment를 정의합니다.

httpd-deploy-items.yaml 파일을 생성하세요.

YAML

# httpd-deploy-items.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: dp-web-apaches
spec:
  replicas: 1
  selector:
    matchLabels:
      app: dp-web-apaches
  template:
    metadata:
      labels:
        app: dp-web-apaches
    spec:
      volumes:
      - name: configmap-volume
        configMap:
          name: start-k8s
          # `items`를 사용해 여러 키를 각각 다른 파일로 마운트
          items:
          - key: k8s
            path: k8s_fullname.txt
          - key: container
            path: container_type.txt
      containers:
      - image: httpd:latest
        name: httpd
        ports:
        - containerPort: 80
        volumeMounts:
        - name: configmap-volume
          mountPath: /etc/config
3단계: 리소스 생성 및 확인
작성한 YAML 파일을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash

$ kubectl apply -f httpd-deploy-items.yaml
$ kubectl wait --for=condition=Ready pod -l app=dp-web-apaches --timeout=120s
4단계: 마운트된 볼륨(파일) 확인
컨테이너에 접속하여 우리가 선택하고 이름을 바꾼 파일들이 정확하게 마운트되었는지 확인합니다.

Bash

# Pod 이름 가져오기
$ POD_NAME=$(kubectl get pods -l app=dp-web-apaches -o jsonpath='{.items[0].metadata.name}')

# /etc/config 디렉터리의 파일 목록 확인
$ kubectl exec $POD_NAME -- ls /etc/config
출력 예상: container_type.txt와 k8s_fullname.txt 라는 두 개의 파일이 보입니다.

Bash

# 각 파일의 내용 확인
$ kubectl exec $POD_NAME -- cat /etc/config/k8s_fullname.txt
# 예상 결과: kubernetes
$ kubectl exec $POD_NAME -- cat /etc/config/container_type.txt
# 예상 결과: docker
💡 심화 확인 팁: describe pod 명령어를 사용하면 Pod의 Volumes 섹션과 컨테이너의 Mounts 섹션에서 ConfigMap 볼륨이 어떻게 설정되고 연결되었는지 상세히 확인할 수 있습니다.

Bash

$ kubectl describe pod $POD_NAME
5단계: 실습 리소스 정리
Bash

$ kubectl delete deployment dp-web-apaches
$ kubectl delete configmap start-k8s

--------------------------------------------------------------------------

🚀 ConfigMap 실습: 파일로부터 ConfigMap 생성하기 (--from-file)
🎯 목표: kubectl create configmap 명령어와 --from-file 옵션을 사용하여, 기존 파일을 쿠버네티스 ConfigMap으로 만드는 방법을 실습합니다.

💡 핵심 개념:
--from-file 옵션은 이미 존재하는 설정 파일(예: nginx.conf, index.html)의 내용을 ConfigMap 데이터로 가져올 때 사용합니다. 키(key)를 지정하는 방식에 따라 두 가지 형태로 사용할 수 있습니다.

사용 방식	생성되는 데이터의 key
--from-file=<파일경로>	파일 이름 (index.html)
--from-file=<원하는_key>=<파일경로>	직접 지정한 이름 (mykey)
단계별 실습
1단계: 준비 - 실습용 파일 생성
ConfigMap으로 만들 원본 파일을 먼저 생성합니다.

Bash

$ echo "Hello, World" > index.html
2단계: 기본 방식으로 ConfigMap 생성 (파일 이름 = Key)
--from-file 옵션에 파일 경로만 지정하여 ConfigMap을 생성합니다.

ConfigMap 생성:

Bash

$ kubectl create configmap index-file --from-file=index.html
생성 결과 확인:
describe 명령어로 ConfigMap의 내용을 확인합니다.

Bash

$ kubectl describe configmap index-file
✨ 핵심 확인 포인트: Data 섹션을 보면, **파일 이름인 index.html이 그대로 key**가 되고, 파일 내용이 value가 된 것을 볼 수 있습니다.

Data
====
index.html:
----
Hello, World
3단계: 키(Key)를 지정하여 ConfigMap 생성
이번에는 --from-file=<key>=<파일경로> 형식을 사용하여, ConfigMap에 저장될 데이터의 키를 mykey로 직접 지정합니다.

ConfigMap 생성:

Bash

$ kubectl create configmap index-file-key --from-file=mykey=index.html
생성 결과 확인:

Bash

$ kubectl describe configmap index-file-key
✨ 핵심 확인 포인트: Data 섹션을 보면, 이번에는 **파일 이름이 아닌 우리가 지정한 mykey가 key**가 된 것을 확인할 수 있습니다.

Data
====
mykey:
----
Hello, World
4단계: 실습 리소스 정리
실습이 끝나면 생성했던 ConfigMap들과 로컬 파일을 모두 삭제하여 환경을 정리합니다.

Bash

$ kubectl delete configmap index-file index-file-key
$ rm index.html

--------------------------------------------------------------------------

🚀 LoadBalancer 인그레스 실습: 경로 기반 라우팅 최종 완성하기
🎯 목표: 실제 서비스 환경과 유사하게, LoadBalancer 타입의 외부 IP를 가진 인그레스 컨트롤러를 구성합니다. 그 후, URL 경로에 따라 각기 다른 웹 애플리케이션으로 트래픽을 분산시키는 실습을 진행합니다.

💡 핵심 개념:

인그레스 컨트롤러 (Ingress Controller): 클러스터 외부의 트래픽이 내부 서비스로 들어오는 것을 관리하는 '교통 경찰'입니다.

LoadBalancer 타입 서비스: 인그레스 컨트롤러 자체를 외부에 노출하는 가장 표준적인 방법입니다. 클라우드 환경에서는 외부 IP를 가진 로드밸런서를 자동으로 생성해주며, 온프레미스 환경에서는 MetalLB와 같은 추가적인 솔루션이 필요합니다.

ConfigMap: HTML 파일과 같은 설정 데이터를 YAML에 정의하여 Pod에 주입하는 역할을 합니다.

인그레스 규칙 (Ingress Rule): /, /shopping 등 특정 경로로 들어온 요청을 어떤 서비스로 전달할지 정의하는 규칙입니다.

1단계: LoadBalancer 타입의 NGINX 인그레스 컨트롤러 설치
먼저, 외부 트래픽을 받을 LoadBalancer 타입의 인그레스 컨트롤러를 설치합니다.

설치 파일 다운로드 및 수정:
NGINX 인그레스 컨트롤러의 공식 설치 YAML 파일을 다운로드합니다.

Bash

$ wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.1/deploy/static/provider/baremetal/deploy.yaml
다운로드한 deploy.yaml 파일을 열어, ingress-nginx-controller 서비스의 타입을 NodePort에서 LoadBalancer로 수정합니다.

Bash

$ vim deploy.yaml
YAML

# deploy.yaml 파일 내에서 아래 부분을 찾아 수정
...
kind: Service
apiVersion: v1
metadata:
  name: ingress-nginx-controller
  namespace: ingress-nginx
spec:
  type: LoadBalancer # <-- NodePort를 LoadBalancer로 변경
...
인그레스 컨트롤러 배포:
수정한 YAML 파일을 클러스터에 적용합니다.

Bash

$ kubectl apply -f deploy.yaml
외부 IP 확인:
잠시 후, ingress-nginx-controller 서비스의 EXTERNAL-IP가 할당되었는지 확인합니다. (클라우드 환경이 아니면 <pending> 상태일 수 있으며, 이 경우 MetalLB 실습이 필요합니다.)

Bash

$ kubectl get svc -n ingress-nginx
2단계: 4개의 웹 애플리케이션 배포
각기 다른 HTML 페이지를 보여주는 4개의 애플리케이션 그룹(Deployment + Service)과 페이지 내용이 담긴 ConfigMap을 배포합니다.

참고: 이 단계는 이전 실습에서 생성했던 html-configs.yaml과 app-deployments.yaml 파일을 사용하는 것과 동일합니다. 이번에는 하나의 파일로 합쳐서 진행합니다.

all-apps.yaml 파일을 생성하세요.

YAML

# all-apps.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: main-html
data:
  index.html: "<html><h1>Welcome to Main Page</h1></html>"
---
# ... (shopping, order, customer ConfigMap 정의) ...
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pod-main
spec:
  replicas: 1
  selector: { matchLabels: { app: main } }
  template:
    metadata: { labels: { app: main } }
    spec:
      containers:
      - name: container
        image: nginx:latest
        ports: [{ containerPort: 80 }]
        volumeMounts:
        - name: html-volume
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html-volume
        configMap: { name: main-html }
---
apiVersion: v1
kind: Service
metadata: { name: svc-main }
spec:
  selector: { app: main }
  ports: [{ port: 80 }]
---
# ... (shopping, order, customer Deployment 및 Service 정의) ...
모든 애플리케이션 배포:

Bash

$ kubectl apply -f all-apps.yaml
3단계: 인그레스 규칙 생성 및 적용
4개의 서비스를 하나로 묶어줄 인그레스 규칙을 정의하고 적용합니다.

ingress-rule.yaml 파일을 생성하세요.

YAML

# ingress-rule.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: service-lb
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service: { name: svc-main, port: { number: 80 } }
      - path: /shopping
        pathType: Prefix
        backend:
          service: { name: svc-shopping, port: { number: 80 } }
      - path: /order
        pathType: Prefix
        backend:
          service: { name: svc-order, port: { number: 80 } }
      - path: /customer
        pathType: Prefix
        backend:
          service: { name: svc-customer, port: { number: 80 } }
인그레스 규칙 적용 및 확인:

Bash

$ kubectl apply -f ingress-rule.yaml
$ kubectl get ingress
$ kubectl describe ingress service-lb
4단계: 최종 테스트
1단계에서 확인한 인그레스 컨트롤러의 EXTERNAL-IP를 사용하여 각 경로로 접속이 잘 되는지 확인합니다.

Bash

# <EXTERNAL_IP>는 1단계에서 확인한 실제 IP로 변경
$ export LB_IP=$(kubectl get svc -n ingress-nginx ingress-nginx-controller -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

# Main 페이지 접속
$ curl http://$LB_IP/
# Shopping 페이지 접속
$ curl http://$LB_IP/shopping
# Order 페이지 접속
$ curl http://$LB_IP/order
# Customer 페이지 접속
$ curl http://$LB_IP/customer
5단계: 실습 리소스 정리
실습이 끝나면 생성했던 모든 리소스를 삭제하여 환경을 정리합니다.

Bash

$ kubectl delete -f ingress-rule.yaml
$ kubectl delete -f all-apps.yaml
$ kubectl delete -f deploy.yaml

