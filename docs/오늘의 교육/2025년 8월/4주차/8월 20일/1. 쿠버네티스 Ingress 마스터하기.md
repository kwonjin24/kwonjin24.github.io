---
layout: default
title: 쿠버네티스 Ingress 마스터하기 실전 경로 기반 라우팅 실습
parent: 8월 20일
nav_order: 2
---

# 2025년 8월 20일 교육 내용

# 쿠버네티스


## 쿠버네티스 Ingress: 외부 트래픽 관리의 마스터
**인그레스(Ingress)**는 클러스터 외부에서 들어오는 HTTP(S) 요청을 내부 서비스로 전달하는 똑똑한 '안내 데스크' 또는 '게이트웨이' 역할을 하는 API 오브젝트입니다.

다양한 서비스(애플리케이션)를 외부에 노출할 때, NodePort나 LoadBalancer 타입을 사용하면 서비스마다 별도의 "외부용 문"을 만들어야 해서 복잡하고 비용이 많이 듭니다. 인그레스는 단 하나의 정문을 통해 모든 요청을 받은 뒤, 요청의 내용(도메인, URL 경로 등)을 보고 알맞은 서비스로 안내해주는 효율적인 방식을 제공합니다.

    아파트 비유:
    NodePort: "30080번 뒷문으로 들어오세요." (불편하고 관리 힘듦)
    
    LoadBalancer: 각 세대마다 외부로 통하는 전용 현관문을 만들어 줌. (비용이 많이 들고 비효율적)

    Ingress: 모든 방문객이 **하나의 정문(인그레스 컨트롤러)**으로 들어와, 안내 데스크에 "A회사에 방문했습니다(a.com)" 라고 말하면, 안내 데스크가 **규칙(인그레스 리소스)**에 따라 올바른 회사로 안내해 줌.

### 💡 사용 이유와 목적 (Why Ingress?)
단일 IP 주소로 여러 서비스 노출: 여러 웹 서비스(예: 블로그, 쇼핑몰, API)를 하나의 IP 주소나 도메인(예: example.com)으로 통합하여 관리할 수 있습니다.

세밀한 트래픽 라우팅: 요청의 **경로(Path)**나 호스트(Host) 이름에 따라 다른 서비스로 트래픽을 라우팅하는 규칙을 정의할 수 있습니다. 예를 들어, example.com/api는 API 서비스로, example.com/blog는 블로그 서비스로 보낼 수 있습니다.

TLS/SSL 종료: 클라이언트와 인그레스 사이의 통신에 SSL 인증서를 적용하여 보안 연결을 설정합니다. 이를 통해 내부 서비스들은 암호화에 대한 부담 없이 평문 통신을 할 수 있어 관리가 중앙화되고 편리해집니다.

로드 밸런싱: 인그레스는 기본적으로 서비스의 여러 파드로 트래픽을 균등하게 분산하여 부하를 줄이고 가용성을 높입니다.

### 🧩 인그레스 구성 요소: 요청서와 실행자
인그레스가 동작하려면 반드시 아래 두 가지가 모두 클러스터에 존재해야 합니다.

1) 인그레스 리소스 (Ingress Resource) 📜
역할: 사용자가 kubectl 명령어로 생성하는 YAML 파일 형태의 API 오브젝트입니다. **"이렇게 라우팅 해달라"**는 규칙이 담긴 '요청서' 또는 **'방문 규칙서'**입니다.

포함 내용: host(도메인), path(경로), 연결할 service 이름, port 번호, TLS 설정 등을 포함합니다.

특징: 이 YAML 파일 자체는 규칙을 선언할 뿐, 혼자서는 아무런 동작도 하지 않습니다.

2) 인그레스 컨트롤러 (Ingress Controller) 👮‍♂️
역할: 인그레스 리소스에 정의된 규칙을 실제로 구현하고 실행하는 클러스터 내의 **애플리케이션(파드)**입니다. 규칙을 실행하는 '실체' 또는 **'안내 데스크 직원'**입니다.

포함 내용: 클러스터 외부와 연결되는 로드 밸런서 역할을 수행하며, 트래픽을 감지하여 규칙에 따라 라우팅합니다.

특징: 인그레스 리소스를 지속적으로 감시하며, 규칙이 변경되면 자동으로 자신의 설정을 업데이트하여 트래픽을 올바른 서비스로 전달합니다. (쿠버네티스에 기본 내장되어 있지 않아 NGINX Ingress Controller, Traefik 등을 직접 설치해야 합니다.)

### 📈 인그레스 처리 프로세스
외부 요청 유입: 외부 클라이언트가 웹 브라우저 등을 통해 shop.example.com으로 요청을 보냅니다.

인그레스 컨트롤러 도착: DNS는 해당 도메인을 인그레스 컨트롤러에 할당된 외부 IP 주소로 해석합니다. 요청은 이 IP 주소를 통해 인그레스 컨트롤러에 도착합니다.

규칙 기반 라우팅: 인그레스 컨트롤러는 인그레스 리소스에 정의된 규칙을 확인합니다. "요청 호스트가 shop.example.com이면 shop-service로 보내라"는 규칙을 찾아냅니다.

서비스로 전달: 인그레스 컨트롤러는 요청을 해당 서비스인 shop-service로 전달합니다.

파드로 분산: shop-service는 연결된 파드들의 IP 목록을 기반으로 요청을 고르게 분산시킵니다.

애플리케이션 응답: 요청을 받은 파드가 응답을 생성하고, 이 응답은 역순으로 클라이언트에 전달됩니다.

[외부 사용자] → [인터넷] → [로드밸런서 (인그레스 컨트롤러)] → [인그레스 컨트롤러 파드] → [규칙 확인 (인그레스 리소스)] → [서비스] → [애플리케이션 파드]

### ✨ 인그레스의 주요 기능 (YAML 예시)
가. 가상 호스팅 (Name-based Virtual Hosting)
하나의 IP로 여러 도메인을 운영합니다.


YAML
```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: virtual-host-ingress
spec:
  rules:
  - host: "store.example.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: store-service
            port:
              number: 80
  - host: "blog.example.com"
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: blog-service
            port:
              number: 80
```

나. 경로 기반 라우팅 (Path-based Routing)
하나의 도메인에서 URL 경로에 따라 다른 서비스로 분기합니다.

YAML
```
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: path-based-ingress
spec:
  rules:
  - host: "example.com"
    http:
      paths:
      - path: /video
        pathType: Prefix
        backend:
          service:
            name: video-service
            port:
              number: 80
      - path: /game
        pathType: Prefix
        backend:
          service:
            name: game-service
            port:
              number: 80
```

### 요약
**인그레스(Ingress)**는 "무엇을 할지"에 대한 명세서이고, **인그레스 컨트롤러(Ingress Controller)**는 그 명세서를 보고 "실제로 행동하는" 주체입니다. 이 둘의 조합을 통해 개발자는 복잡한 네트워크 설정 없이도 HTTP/S 기반의 웹 서비스를 효율적으로 외부에 노출할 수 있습니다.

--------------------------------------------------------------------------

## NGINX 인그레스 컨트롤러 설치 가이드 (On-Premise / NodePort 방식)
#### 🎯 목표: 쿠버네티스 클러스터의 '교통 경찰' 역할을 하는 NGINX 인그레스 컨트롤러를 설치합니다. 온프레미스(On-Premise) 환경에서 외부 트래픽을 받을 수 있도록 NodePort 방식으로 서비스를 노출시키는 것을 목표로 합니다.

#### 💡 핵심 개념: 인그레스 컨트롤러는 사용자가 YAML로 정의한 인그레스 규칙(라우팅 규칙)을 읽고 실제로 실행하는 핵심 프로그램입니다. 이 컨트롤러가 설치되어 있어야만 인그레스 기능이 동작합니다.

## 1단계: 공식 설치 파일 다운로드
가장 먼저, NGINX 인그레스 컨트롤러 설치에 필요한 모든 구성요소가 정의된 공식 YAML 파일을 다운로드합니다.

Bash

## deploy.yaml 이라는 이름으로 설치 파일을 다운로드합니다.

```
wget https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.3.1/deploy/static/provider/baremetal/deploy.yaml -O deploy.yaml
```

추가 설명: 이 baremetal용 공식 파일은 온프레미스 환경을 위해 만들어졌지만, 서비스 노출 방식은 기본적으로 type: LoadBalancer로 설정되어 있습니다. 다음 단계에서 이 부분을 우리 환경에 맞게 NodePort로 수정합니다.

## 2단계: 서비스 타입 수정 (NodePort 방식)
다운로드한 deploy.yaml 파일을 vi 편집기로 열고, 줄 번호를 켠 뒤(:set nu 입력), ingress-nginx-controller 서비스의 spec 부분을 아래 내용으로 교체합니다.

파일의 345번째 줄 근처에 있는 spec: 블록 전체를 아래 내용으로 완전히 교체하고 저장하세요.

vi deploy.yaml
YAML
```
345  spec:
346    type: NodePort
347    ipFamilies:
348    - IPv4
349    ipFamilyPolicy: SingleStack
350    ports:
351    - appProtocol: http
352      name: http
353      port: 80
354      protocol: TCP
355      targetPort: http
356      nodePort: 30080
357    - appProtocol: https
358      name: https
359      port: 443
360      protocol: TCP
361      targetPort: https
362      nodePort: 30443
363    selector:
364      app.kubernetes.io/component: controller
365      app.kubernetes.io/instance: ingress-nginx
366      app.kubernetes.io/name: ingress-nginx
```
추가 설명: 이 작업은 인그레스 컨트롤러가 외부 HTTP(80) 요청을 노드의 30080 포트로, HTTPS(443) 요청을 30443 포트로 받을 수 있도록 설정하는 과정입니다.

## 3단계: 인그레스 컨트롤러 배포
수정한 deploy.yaml 파일을 클러스터에 적용하여 인그레스 컨트롤러를 배포합니다.

Bash
```
kubectl apply -f deploy.yaml
```
추가 설명: 이 명령어 한 번으로 파일 안에 정의된 Namespace, Deployment, Service, ConfigMap, ServiceAccount, Role, ClusterRole, RoleBinding, ClusterRoleBinding 등 모든 리소스가 생성됩니다.

## 4단계: 설치 상태 확인
배포가 정상적으로 완료되었는지 확인하는 것은 매우 중요합니다.

가. 파드 상태 실시간 확인
watch 명령어로 컨트롤러 파드가 Running 상태가 될 때까지 실시간으로 확인합니다.

Bash
```
# ingress-nginx 네임스페이스의 파드 상태를 감시합니다. (종료는 Ctrl+C)
watch kubectl get pods -n ingress-nginx
```
ingress-nginx-controller-... 파드의 STATUS가 Running, READY가 1/1이 되면 성공입니다.

나. 서비스 상태 확인
서비스가 NodePort 타입으로 잘 생성되었고, 포트가 정확히 열렸는지 확인합니다.
Bash
```
kubectl get svc -n ingress-nginx
```
PORT(S) 컬럼에 80:30080/TCP,443:30443/TCP가 보이면 정상입니다.

## 5단계: 외부 접속 테스트
마지막으로, 클러스터 외부에서 워커 노드의 IP와 NodePort를 이용해 인그레스 컨트롤러에 접속되는지 테스트합니다.

Bash
# <WORKER_NODE_IP> 부분은 실제 워커 노드의 IP 주소로 변경하세요.
```
curl http://<WORKER_NODE_IP>:30080
```
정상 결과: 404 Not Found 라는 NGINX 페이지의 HTML 코드가 보이면 설치에 성공한 것입니다. 이것은 컨트롤러는 잘 실행되었지만, 아직 아무런 라우팅 규칙(인그레스 리소스)이 없어서 "요청을 어디로 보내야 할지 모르겠다"고 응답하는 정상적인 상태입니다.


--------------------------------------------------------------------------

## 🚀 인그레스(Ingress) 규칙 적용 실습 
#### 🎯 목표: 2개의 다른 웹 애플리케이션을 배포한 뒤, 단일 인그레스 규칙을 만들어 URL 경로(/apple, /banana)에 따라 각기 다른 애플리케이션으로 트래픽을 라우팅하는 실습을 진행합니다.

이 실습은 쿠버네티스의 '인그레스(Ingress)'를 이용해 똑똑한 교통정리를 하는 방법을 배우는 것입니다.

#### 🎯 이 실습의 핵심 목표
만약 우리가 외부에 공개해야 할 웹 서비스가 'Apple 서비스'와 'Banana 서비스' 두 개가 있다면 어떻게 해야 할까요? 각 서비스마다 NodePort나 LoadBalancer를 만들어 두 개의 다른 주소를 외부에 알려줘야 할까요? 서비스가 100개라면 100개의 주소가 필요할까요?

인그레스는 이 문제를 아주 효율적으로 해결합니다.

쇼핑몰 비유:
인그레스 컨트롤러 (NodePort 30080): 거대한 **쇼핑몰의 '정문'**입니다. 주소는 딱 하나입니다.
apple-app.yaml: 쇼핑몰 안에 입점한 **'애플 스토어'**를 만드는 과정입니다.
banana-app.yaml: 쇼핑몰 안에 입점한 **'바나나 가게'**를 만드는 과정입니다.
example-ingress.yaml: 쇼핑몰 정문에 세워진 **'층별 안내도(디렉토리)'**를 만드는 과정입니다.

이 실습은 바로 이 **층별 안내도(인그레스 규칙)**를 만드는 방법을 배우는 것입니다.
apple-app.yaml과 banana-app.yaml로 쇼핑몰 안에 두 개의 다른 가게를 입점시킵니다.
example-ingress.yaml로 층별 안내도를 만듭니다. 이 안내도에는 다음과 같이 쓰여 있습니다.

"혹시 /apple을 찾아오신 손님은 애플 스토어로 안내하세요."
"혹시 /banana를 찾아오신 손님은 바나나 가게로 안내하세요."

최종 테스트에서 curl을 사용하는 것은 손님이 쇼핑몰 정문으로 찾아와 안내도를 보고 원하는 가게로 찾아가는 과정과 같습니다.

curl http://<쇼핑몰주소>:30080/apple → 안내도를 보고 애플 스토어로 찾아감 → "This is APPLE service" 응답

curl http://<쇼핑몰주소>:30080/banana → 안내도를 보고 바나나 가게로 찾아감 → "This is BANANA service" 응답

### 요약
결론적으로, 이 실습은 단 하나의 외부 IP 주소(노드 IP + NodePort)를 '정문'으로 사용하면서, URL 경로에 따라 들어온 요청을 각기 다른 내부 서비스(파드 그룹)로 지능적으로 분배하는 쿠버네티스의 강력한 경로 기반 라우팅(Path-Based Routing) 기능을 배우는 과정입니다.

사전 준비: 이전 실습을 통해 NGINX 인그레스 컨트롤러가 클러스터에 정상적으로 설치 및 실행되고 있어야 합니다.

1단계: 첫 번째 애플리케이션(apple) 생성
apple-app.yaml 파일을 생성하고 아래 전체 코드를 붙여넣으세요. 이 파일은 'apple' 앱을 실행하는 Deployment와 내부적으로 연결해 줄 Service를 정의합니다.

vi apple-app.yaml
Bash
```

apiVersion: apps/v1
kind: Deployment
metadata:
  name: apple-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: apple
  template:
    metadata:
      labels:
        app: apple
    spec:
      containers:
      - name: apple-container
        image: hashicorp/http-echo
        args:
        - "-text=This is APPLE service"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: apple-service
spec:
  selector:
    app: apple
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5678

```

2단계: 두 번째 애플리케이션(banana) 생성
banana-app.yaml 파일을 생성하고 아래 전체 코드를 붙여넣으세요. 'banana' 앱을 위한 Deployment와 Service입니다.

vi banana-app.yaml
Bash
```

apiVersion: apps/v1
kind: Deployment
metadata:
  name: banana-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: banana
  template:
    metadata:
      labels:
        app: banana
    spec:
      containers:
      - name: banana-container
        image: hashicorp/http-echo
        args:
        - "-text=This is BANANA service"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: banana-service
spec:
  selector:
    app: banana
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5678

```
3단계: 애플리케이션 배포
두 개의 YAML 파일을 이용해 애플리케이션들을 클러스터에 배포하고, 파드와 서비스가 정상적으로 실행되는지 확인합니다.
Bash
```
kubectl apply -f apple-app.yaml
kubectl apply -f banana-app.yaml

# 잠시 후 아래 명령어로 파드와 서비스가 Running 상태인지 확인
kubectl get pods,svc
```

4단계: 인그레스 규칙(Routing Rule) 생성
이제 두 애플리케이션으로 트래픽을 분기시킬 라우팅 규칙을 정의합니다.

vi example-ingress.yaml
Bash
```

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-ingress
spec:
  ingressClassName: "nginx"       # 이 필드를 추가합니다.
  rules:
  - http:
      paths:
      - path: /apple
        pathType: Prefix
        backend:
          service:
            name: apple-service
            port:
              number: 80
      - path: /banana
        pathType: Prefix
        backend:
          service:
            name: banana-service
            port:
              number: 80

```

5단계: 인그레스 규칙 적용
생성한 인그레스 규칙을 클러스터에 적용하고, 규칙이 잘 생성되었는지 확인합니다.

Bash
```
kubectl apply -f example-ingress.yaml

# 인그레스 규칙이 생성되었는지 확인
kubectl get ingress
```

6단계: 최종 테스트
인그레스 컨트롤러의 NodePort(30080)와 방금 정의한 경로를 조합하여 각 애플리케이션에 정상적으로 접근되는지 확인합니다.

Bash
```
# /apple 경로로 요청 보내기 (apple-service 응답 확인)
curl http://<WORKER_NODE_IP>:30080/apple
# 예상 결과 --> This is APPLE service

# /banana 경로로 요청 보내기 (banana-service 응답 확인)
curl http://<WORKER_NODE_IP>:30080/banana
# 예상 결과 --> This is BANANA service
```
*<WORKER_NODE_IP>는 10.10.8.104, 105, 106 중 하나를 사용하시면 됩니다.

7단계: 실습 리소스 전체 삭제
실습이 끝나면, 생성했던 모든 리소스를 아래 명령어로 깨끗하게 삭제합니다.

Bash
```
kubectl delete -f example-ingress.yaml
kubectl delete -f apple-app.yaml
kubectl delete -f banana-app.yaml
```

--------------------------------------------------------------------------

## 🚀 NGINX 인그레스 실습 
#### 🎯 목표: 각각 다른 웹 페이지를 보여주는 2개의 독립된 애플리케이션을 배포합니다. 그리고 단 하나의 인그레스(Ingress) 규칙을 만들어, 사용자가 접속하는 URL 경로에 따라 올바른 애플리케이션으로 트래픽이 자동으로 라우팅되도록 구성합니다.

사전 준비: NGINX 인그레스 컨트롤러가 클러스터에 정상적으로 설치 및 실행되고 있어야 하며, NodePort 30080을 통해 외부에서 접근 가능한 상태여야 합니다.

## 1부: 2개의 웹 애플리케이션 배포하기
1단계: Main 페이지 애플리케이션 생성
main-app.yaml 파일은 / 경로로 접속했을 때 보여줄 메인 페이지용 애플리케이션을 정의합니다.

vi main-app.yaml
YAML
```

apiVersion: v1
kind: ConfigMap
metadata:
  name: main-html
data:
  index.html: |
    <html><h1>Welcome to Main Page</h1></html>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pod-main
spec:
  replicas: 1
  selector:
    matchLabels:
      category: mainurl
  template:
    metadata:
      labels:
        category: mainurl
    spec:
      containers:
      - name: container
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html-volume
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html-volume
        configMap:
          name: main-html
---
apiVersion: v1
kind: Service
metadata:
  name: svc-mainurl
spec:
  selector:
    category: mainurl
  ports:
  - port: 80

```
2단계: Shopping 페이지 애플리케이션 생성
shopping-app.yaml 파일은 /shopping 경로로 접속했을 때 보여줄 쇼핑 페이지용 애플리케이션을 정의합니다.

vi shopping-app.yaml
YAML
```

apiVersion: v1
kind: ConfigMap
metadata:
  name: shopping-html
data:
  index.html: |
    <html><h1>Welcome to Shopping Center Page</h1></html>
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: pod-shopping
spec:
  replicas: 1
  selector:
    matchLabels:
      category: shopping
  template:
    metadata:
      labels:
        category: shopping
    spec:
      containers:
      - name: container
        image: nginx:latest
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html-volume
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html-volume
        configMap:
          name: shopping-html
---
apiVersion: v1
kind: Service
metadata:
  name: svc-shopping
spec:
  selector:
    category: shopping
  ports:
  - port: 80

```

3단계: 모든 애플리케이션 배포
생성한 2개의 YAML 파일을 한 번에 적용하여 모든 리소스를 클러스터에 배포합니다.

Bash
```
kubectl apply -f main-app.yaml -f shopping-app.yaml
```

## 2부: 인그레스 규칙 생성 및 적용
4단계: 인그레스 규칙 파일 생성
2개의 서비스를 하나로 묶어줄 인그레스 규칙("층별 안내도")을 정의합니다.

vi ingress-rule.yaml
YAML
```

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: ingress-routes
spec:
  ingressClassName: nginx
  rules:
  - http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: svc-mainurl
            port:
              number: 80
      - path: /shopping
        pathType: Prefix
        backend:
          service:
            name: svc-shopping
            port:
              number: 80

```

5단계: 인그레스 규칙 적용 및 상태 확인
생성한 인그레스 규칙을 클러스터에 적용하고, -o wide 옵션으로 어떤 주소(ADDRESS)로 요청을 받고 있는지 상세하게 확인합니다.

Bash
```
kubectl apply -f ingress-rule.yaml

# 인그레스 규칙의 상세 상태 확인
kubectl get ingress ingress-routes -o wide
```
ADDRESS 컬럼에 클러스터 노드들의 IP 주소가 표시되면, 인그레스 컨트롤러가 규칙을 성공적으로 인지한 것입니다.

## 3부: 최종 테스트, 추가 학습 및 정리
6단계: 경로별 접속 테스트
가. 터미널에서 curl로 테스트하기

Bash
```
# <WORKER_NODE_IP>는 10.10.8.104, 105, 106 중 하나를 사용하세요.

# 1. Main 페이지 접속
curl http://<WORKER_NODE_IP>:30080/
# 예상 결과 --> <html><h1>Welcome to Main Page</h1></html>

# 2. Shopping 페이지 접속
curl http://<WORKER_NODE_IP>:30080/shopping
# 예상 결과 --> <html><h1>Welcome to Shopping Center Page</h1></html>
```

나. 웹 브라우저로 직접 확인하기
curl 테스트도 좋지만, 웹 브라우저 주소창에 아래 주소를 직접 입력하여 페이지가 잘 뜨는 것을 눈으로 보면 훨씬 직관적입니다.

http://<WORKER_NODE_IP>:30080/

http://<WORKER_NODE_IP>:30080/shopping

## 📌 추가 학습 포인트
이번 실습은 경로 기반 라우팅을 다루었습니다. 인그레스로는 다음과 같은 고급 기능도 구현할 수 있습니다.

호스트 기반 라우팅: shop.example.com, blog.example.com 처럼 도메인 이름에 따라 다른 서비스로 트래픽을 보낼 수 있습니다.

TLS/HTTPS 적용: 쿠버네티스 시크릿(Secret)에 SSL 인증서를 저장하고 인그레스 규칙에 연결하여 https 보안 연결을 쉽게 설정할 수 있습니다.

7단계: 실습 리소스 전체 삭제
실습이 끝나면, 생성했던 모든 리소스를 아래 명령어로 깨끗하게 삭제합니다.

Bash
```
kubectl delete -f ingress-rule.yaml -f main-app.yaml -f shopping-app.yaml
```

--------------------------------------------------------------------------

## 🚀 인그레스(Ingress) 규칙 적용 실습 

#### 🎯 목표: 2개의 다른 웹 애플리케이션을 배포, 단일 인그레스 규칙을 생성하여 URL 경로(/apple, /banana)에 따라 각각의 애플리케이션으로 트래픽 라우팅

#### 📌 사전 준비
클러스터에 NGINX 인그레스 컨트롤러가 설치 및 실행 중이어야 함

1단계: 실습용 네임스페이스 생성 (권장)

실습 리소스를 한 번에 관리/삭제하기 위해 전용 네임스페이스를 생성합니다.
```
kubectl create ns ingress-lab
kubectl config set-context --current --namespace=ingress-lab
```

2단계: 첫 번째 애플리케이션(apple) 생성

vi 01-apple-app.yaml
```

apiVersion: apps/v1
kind: Deployment
metadata:
  name: apple-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: apple
  template:
    metadata:
      labels:
        app: apple
    spec:
      containers:
      - name: apple-container
        image: hashicorp/http-echo
        args:
        - "-text=This is APPLE service"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: apple-service
spec:
  selector:
    app: apple
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5678

```

적용:
```
kubectl apply -f 01-apple-app.yaml
```

3단계: 두 번째 애플리케이션(banana) 생성

vi 02-banana-app.yaml
```

apiVersion: apps/v1
kind: Deployment
metadata:
  name: banana-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: banana
  template:
    metadata:
      labels:
        app: banana
    spec:
      containers:
      - name: banana-container
        image: hashicorp/http-echo
        args:
        - "-text=This is BANANA service"
        ports:
        - containerPort: 5678
---
apiVersion: v1
kind: Service
metadata:
  name: banana-service
spec:
  selector:
    app: banana
  ports:
  - protocol: TCP
    port: 80
    targetPort: 5678

```

적용:
```
kubectl apply -f 02-banana-app.yaml
```

4단계: 인그레스 규칙(Routing Rule) 생성

vi 03-example-ingress.yaml
```

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: example-ingress
spec:
  ingressClassName: nginx 
  rules:
  - http:
      paths:
      - path: /apple
        pathType: Prefix
        backend:
          service:
            name: apple-service
            port:
              number: 80
      - path: /banana
        pathType: Prefix
        backend:
          service:
            name: banana-service
            port:
              number: 80

```

적용:
```
kubectl apply -f 03-example-ingress.yaml
```

5단계: 상태 확인
```
kubectl get pods,svc
kubectl get ingress example-ingress -o wide
```

Ingress의 ADDRESS 컬럼에 값(NodePort IP or EXTERNAL-IP)이 표시되어야 정상 동작

6단계: 최종 테스트

📌 Ingress Controller의 NodePort(예: 30080) 또는 EXTERNAL-IP 사용
```
# apple 서비스 확인
curl http://<WORKER_NODE_IP>:30080/apple
# 예상 출력: This is APPLE service

# banana 서비스 확인
curl http://<WORKER_NODE_IP>:30080/banana
# 예상 출력: This is BANANA service
```

👉 브라우저에서도 직접 확인 가능

http://<WORKER_NODE_IP>:30080/apple

http://<WORKER_NODE_IP>:30080/banana

7단계: 실습 리소스 전체 삭제

네임스페이스 단위로 한 번에 정리 가능:
```
kubectl delete ns ingress-lab
```

