---
layout: default
title: 쿠버네티스 시크릿(Secret) 완벽 가이드 개념부터 실전 활용까지
parent: 8월 21일
nav_order: 2
---

# 2025년 8월 20일 교육 내용

# 쿠버네티스

## 📌 쿠버네티스 시크릿(Secret) 완벽 정리
1) 시크릿(Secret)이란 무엇인가?
시크릿은 비밀번호, API 키, TLS 인증서와 같이 민감하고 중요한 데이터를 저장하고 관리하기 위한 쿠버네티스 오브젝트입니다. ConfigMap과 사용법은 매우 유사하지만, 이름 그대로 보안이 필요한 기밀 정보를 다루는 데 특화되어 있습니다.

        👉 쉬운 비유: ConfigMap vs Secret

        ConfigMap: 누구나 볼 수 있는 '공개된 설정값' (예: 웹사이트 테마 색상, 페이지당 게시물 수)

        Secret: **'금고 안의 비밀번호'**처럼 허가된 사람만 접근해야 하는 정보 (예: DB 비밀번호, API 키)

2) 시크릿(Secret)의 주요 특징
시크릿은 민감 정보를 보호하기 위해 다음과 같은 특징을 가집니다.

Base64 인코딩 (Base64 Encoding):

        시크릿에 저장되는 값은 기본적으로 Base64로 인코딩되어 YAML 파일이나 터미널 출력에서 바로 읽기 어렵게 만듭니다.

        ⚠️ 중요: 인코딩(Encoding)은 암호화(Encryption)가 아닙니다. 누구나 간단한 명령어로 디코딩할 수 있으므로, Base64 인코딩 자체를 보안 기능으로 의존해서는 안 됩니다.

메모리 저장 (In-Memory Storage):

        시크릿을 볼륨으로 마운트하면, 기본적으로 디스크가 아닌 **메모리 기반 파일 시스템(tmpfs)**에 저장됩니다. 이는 디스크에 비밀번호가 평문으로 저장되는 것을 방지하여 보안성을 높여줍니다.

크기 제한 및 메모리 사용량:

        하나의 시크릿 오브젝트는 최대 1MiB까지 데이터를 저장할 수 있습니다.

        시크릿은 각 노드의 kubelet 메모리에 저장되므로, 너무 많은 시크릿을 사용하면 노드의 메모리 부족(Out Of Memory) 문제를 유발할 수 있습니다. 꼭 필요한 최소한의 정보만 저장하는 것이 좋습니다.

3) 시크릿(Secret)의 종류
쿠버네티스는 사용 목적에 따라 여러 종류의 시크릿을 제공합니다.

| 종류 | 설명 | 주요 용도 |
|---|---|---|
| Opaque | 기본값. 사용자가 정의하는 임의의 키-값 데이터를 저장합니다.	 | 데이터베이스 비밀번호, 외부 서비스 API 키 등 |
| kubernetes.io/dockerconfigjson | Private Docker Registry의 인증 정보를 저장합니다. | Private 이미지 저장소(Docker Hub, Harbor, ECR 등)에서 이미지를 pull 할 때 |
| kubernetes.io/tls | **TLS 인증서(tls.crt)와 개인 키(tls.key)**를 저장합니다. | Ingress에서 HTTPS 통신을 설정할 때 |
| kubernetes.io/service-account-token | ServiceAccount의 자격 증명을 위한 토큰을 저장합니다. | Pod가 쿠버네티스 API 서버와 통신할 때 권한 증명용 |

4) Pod에서 시크릿을 사용하는 방법
ConfigMap과 마찬가지로, 시크릿은 주로 두 가지 방식으로 Pod에 전달됩니다.

        방법 1: 환경 변수(Environment Variables)로 주입:

            시크릿의 특정 key 값을 컨테이너의 환경 변수로 주입합니다.

            단점: kubectl describe pod 명령어로 Pod 정보를 조회했을 때, 환경 변수 목록에서 시크릿의 key 이름이 노출될 수 있습니다.

        방법 2: 볼륨 마운트(Volume Mount)로 주입 (권장):

            시크릿을 읽기 전용 볼륨으로 컨테이너 내부의 특정 경로에 파일 형태로 마운트합니다.

            장점: 환경 변수 방식보다 더 안전하며, 시크릿이 업데이트되었을 때 Pod를 재시작하지 않아도 마운트된 파일 내용이 자동으로 업데이트됩니다.

5. 시크릿 생성 및 관리
명령형(Imperative) 방식: kubectl create secret
간단한 테스트나 임시 시크릿을 만들 때 편리합니다.

Bash
```
# Opaque 타입 시크릿 생성
kubectl create secret generic my-secret --from-literal=username=admin --from-literal=password='s3cr3t'

# Docker Registry 시크릿 생성
kubectl create secret docker-registry my-docker-secret --docker-server=<your-registry-server> --docker-username=<your-name> --docker-password=<your-pword>
```

        💡 실무 팁: 명령어 뒤에 --dry-run=client -o yaml 옵션을 붙이면, 시크릿을 실제로 생성하지 않고 YAML 파일로 변환하여 출력해 줍니다. 이를 통해 선언형 관리로 쉽게 전환할 수 있습니다.

선언형(Declarative) 방식: YAML 파일 (실무 표준)

        ⚠️ 경고: Base64로 인코딩된 시크릿 값을 Git과 같은 공개된 장소에 절대 저장하면 안 됩니다!

6. 실무 Best Practices: 안전하게 시크릿 관리하기
선언적 방식(GitOps)으로 인프라를 관리할 때, 민감 정보를 Git에 안전하게 저장하기 위해 다음과 같은 도구들이 널리 사용됩니다.

Sealed Secrets:

        쿠버네티스 클러스터에 설치된 컨트롤러만이 해독할 수 있는 암호화된 시크릿(SealedSecret)을 만듭니다. 이 암호화된 파일은 Git에 안전하게 저장할 수 있습니다. 클러스터 내에서 컨트롤러가 이를 감지하고 원래의 Secret으로 변환해 줍니다.

External Secrets Operator:

        시크릿의 원본을 AWS Secrets Manager, HashiCorp Vault, Google Secret Manager와 같은 외부 전문 시크릿 관리 도구에 저장합니다.

        쿠버네티스에는 이 외부 시크릿을 어떻게 가져올지에 대한 **참조 정보(ExternalSecret)**만 저장합니다. 그러면 External Secrets Operator가 주기적으로 외부 시스템에서 실제 값을 가져와 쿠버네티스 Secret을 동기화해 줍니다.

이러한 도구들을 사용하면, 민감 정보를 Git 저장소에서 분리하여 보안을 강화하면서도 선언적인 방식으로 시크릿을 관리할 수 있습니다.

--------------------------------------------------------------------------

## 🚀 Secret 실습: 명령어로 Secret 생성하기
#### 🎯 목표: YAML 파일을 직접 작성하는 대신, kubectl create secret 명령어와 두 가지 다른 옵션(--from-literal, --from-file)을 사용하여 시크릿을 생성하는 방법을 실습합니다. 또한, --dry-run 옵션을 활용하여 선언형 YAML 파일을 생성하는 Best Practice를 익힙니다.

#### 💡 핵심 개념: 
--from-literal=<key>=<value>: 터미널에 직접 입력한 **문자열(literal)**을 value로 하여 시크릿 데이터를 생성합니다. 간단한 비밀번호나 토큰에 유용합니다.

--from-file=<파일경로>: 파일의 내용을 value로 하여 시크릿 데이터를 생성합니다. 파일 이름이 key가 됩니다. TLS 인증서나 개인 키 파일처럼 여러 줄로 된 민감 정보를 다룰 때 유용합니다.

실습 1: --from-literal로 Secret 생성하기
YAML 파일 생성:
        --from-literal 옵션을 사용하여 password라는 키에 dkagh1.이라는 값을 가진 시크릿의 YAML 명세서를 생성합니다. --dry-run=client -o yaml 옵션은 리소스를 클러스터에 바로 생성하는 대신, YAML 파일로 출력해주는 매우 유용한 기능입니다.

Bash
```
kubectl create secret generic my-password \
--from-literal=password=dkagh1. \
--dry-run=client -o yaml > secret.yaml
```

생성된 YAML 확인:
secret.yaml 파일의 내용을 확인하여 dkagh1. 값이 Base64로 자동 인코딩되었는지 확인합니다.

Bash
```
cat secret.yaml
```
        출력 예상:

        YAML
        ```
        apiVersion: v1
        data:
          password: ZGthZ2gxLg== # "dkagh1."이 Base64로 인코딩된 값
        kind: Secret
        metadata:
          name: my-password
        ```

실습 2: --from-file로 Secret 생성하기
실습용 파일 생성:
시크릿으로 만들 원본 파일 두 개를 먼저 생성합니다.

Bash
```
echo "dkagh1." > pw1
echo "dkagh2." > pw2
```

YAML 파일 생성:
--from-file 옵션을 사용하여 pw1과 pw2 파일의 내용을 데이터로 가지는 시크릿의 YAML 명세서를 생성합니다.

Bash
```
kubectl create secret generic my-password-2 \
--from-file=pw1 \
--from-file=pw2 \
--dry-run=client -o yaml > secret-from-file.yaml
```

생성된 YAML 확인:
secret-from-file.yaml 파일의 내용을 확인합니다. **파일 이름(pw1, pw2)이 각각의 key**가 되고, 파일 내용이 Base64로 인코딩되어 저장된 것을 볼 수 있습니다.

Bash
```
cat secret-from-file.yaml
```

실습 3: 생성한 Secret 적용 및 확인
이제 생성한 두 개의 YAML 파일을 클러스터에 적용하고, 시크릿이 잘 만들어졌는지 단계별로 확인합니다.

시크릿 적용:

Bash
```
kubectl apply -f secret.yaml
kubectl apply -f secret-from-file.yaml
```

생성된 시크릿 목록 확인:

Bash
```
kubectl get secret
```
출력 예상: my-password와 my-password-2 시크릿이 목록에 보입니다.

시크릿 내용 직접 확인하기 (Base64 인코딩):
get -o yaml 명령어로 my-password 시크릿의 실제 내용을 확인해 봅시다.

Bash
```
kubectl get secret my-password -o yaml
```

        ✨ 핵심 확인 포인트:
        data 섹션의 password 값이 우리가 아는 dkagh1.이 아닌, 알 수 없는 문자열로 표시됩니다.

        YAML
        ```
        apiVersion: v1
        data:
          password: ZGthZ2gxLg== # <-- Base64로 인코딩된 값
        kind: Secret
        ...
        ```
        여기서 ZGthZ2gxLg== 처럼 보이는 값은 암호화가 아니라 단순 Base64 인코딩이므로, 바로 읽을 수 없습니다. 이는 실수로 비밀번호가 화면에 노출되는 것을 방지하는 최소한의 안전장치입니다.

저장된 값 디코딩하여 최종 확인:
이제 인코딩된 값을 다시 원래의 문자열로 되돌려서(디코딩) 값이 올바르게 저장되었는지 최종 확인합니다.

Bash
```
# my-password 시크릿의 'password' 키 값을 디코딩
kubectl get secret my-password -o jsonpath='{.data.password}' | base64 --decode
```
        출력 예상: dkagh1.

실습 4: 실습 리소스 정리
실습이 끝나면 생성했던 시크릿과 로컬 파일을 모두 삭제하여 환경을 정리합니다.

Bash
```
kubectl delete secret my-password my-password-2
rm secret.yaml secret-from-file.yaml pw1 pw2
```

--------------------------------------------------------------------------

## 🚀 Secret 실습: Secret 값을 환경 변수로 사용하기
#### 🎯 목표: Base64로 인코딩된 데이터를 포함하는 Secret을 YAML 파일로 직접 생성하고, valueFrom을 사용하여 Secret의 특정 값을 컨테이너의 환경 변수로 안전하게 주입하는 방법을 실습합니다.

💡 핵심 개념:

        선언형 Secret: YAML 파일로 Secret을 정의할 때, data 필드에 들어가는 모든 값은 반드시 Base64로 인코딩되어야 합니다.

        secretKeyRef: Pod의 env 섹션에서 valueFrom.secretKeyRef를 사용하면, 지정된 Secret(name)에서 특정 key의 값을 찾아 자동으로 디코딩한 후 컨테이너의 환경 변수로 주입해 줍니다.

단계별 실습
1단계: Secret 데이터 수동 인코딩
먼저, Secret YAML 파일에 넣을 민감한 데이터('root', 'dkagh1.')를 Base64로 직접 인코딩합니다.

        💡 중요: echo 명령어에 -n 옵션을 사용하는 것이 중요합니다. 이 옵션은 불필요한 줄바꿈 문자(\n)가 포함되는 것을 막아 올바른 인코딩 값을 얻게 해줍니다.

Bash
```
# 'root' 문자열 인코딩
echo -n 'root' | base64
# cm9vdA==

# 'dkagh1.' 문자열 인코딩
echo -n 'dkagh1.' | base64
# ZGthZ2gxLg==
```

2단계: Secret YAML 파일 작성
1단계에서 얻은 인코딩된 값들을 사용하여 Secret 리소스를 정의합니다.

vi my-secret.yaml
YAML
```
# my-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: my-secret
# type: Opaque은 사용자가 정의하는 임의의 키-값 데이터를 저장하는
# 가장 일반적인 기본 시크릿 타입을 의미합니다.
type: Opaque
data:
  # 위에서 인코딩한 값을 여기에 붙여넣습니다.
  username: cm9vdA==
  password: ZGthZ2gxLg==
```

3단계: Secret을 사용하는 Pod YAML 파일 작성
valueFrom.secretKeyRef를 사용하여, 위에서 만든 my-secret의 각 키 값을 컨테이너의 환경 변수로 참조하도록 Pod를 정의합니다.

vi pod-uses-secret.yaml

YAML
```
# pod-uses-secret.yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-apl
spec:
  containers:
  - name: nginx
    image: nginx
    env:
    - name: DB_USERNAME
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: username
    - name: DB_PASSWORD
      valueFrom:
        secretKeyRef:
          name: my-secret
          key: password
```

4단계: 리소스 생성 및 확인
작성한 YAML 파일들을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash
```
kubectl apply -f my-secret.yaml
kubectl apply -f pod-uses-secret.yaml
kubectl wait --for=condition=Ready pod/web-apl --timeout=120s
```
5단계: 컨테이너 내부 환경 변수 확인
컨테이너에 접속하여, Secret의 값이 자동으로 디코딩되어 환경 변수로 잘 주입되었는지 확인합니다.

Bash
```
kubectl exec -it web-apl -- env | grep DB_
```

        ✨ 핵심 확인 포인트:
        Base64로 인코딩된 값이 아닌, 원래의 문자열이 환경 변수 값으로 들어간 것을 확인할 수 있습니다.
        ```
        DB_USERNAME=root
        DB_PASSWORD=dkagh1.
        ```
        💡 보안 Best Practice:
        환경 변수로 주입하는 방식은 간편하지만, 컨테이너에 접속하면 env 명령어로 값이 쉽게 노출될 수 있습니다. 더 높은 수준의 보안이 필요할 때는 다음 실습에서 배울 볼륨 마운트(Volume Mount) 방식이 더 안전한 선택입니다.

6단계: 실습 리소스 정리
실습이 끝나면 생성했던 Pod와 Secret을 모두 삭제하여 환경을 정리합니다.

Bash
```
kubectl delete pod web-apl
kubectl delete secret my-secret
```

--------------------------------------------------------------------------

## 🚀 Secret 실습: Secret을 볼륨(파일)으로 마운트하기
#### 🎯 목표: Secret에 저장된 민감 정보를 컨테이너의 특정 경로에 읽기 전용 파일로 안전하게 마운트하는 방법을 실습합니다.

💡 핵심 개념:

        volumes & volumeMounts: spec.volumes에서 사용할 Secret을 정의하고, spec.containers.volumeMounts에서 해당 볼륨을 컨테이너의 특정 경로에 연결합니다.

        Key → 파일, Value → 내용: Secret의 data 필드에 있는 각 키(key)는 파일 이름이 되고, Base64로 인코딩된 값(value)은 디코딩된 후 해당 파일의 내용이 됩니다.

        보안상 이점: 이 방식은 환경 변수와 달리, kubectl describe pod 명령으로 시크릿의 사용 여부를 직접적으로 노출하지 않습니다. 또한, 시크릿은 디스크가 아닌 **메모리 기반 파일 시스템(tmpfs)**에 마운트되어 보안에 더 유리합니다.

단계별 실습
1단계: Secret 데이터 수동 인코딩
먼저, Secret YAML 파일에 넣을 민감한 데이터('root', 'dkagh1.')를 Base64로 직접 인코딩합니다.

Bash
```
# -n 옵션은 불필요한 줄바꿈 문자를 제외하여 정확한 인코딩 값을 생성합니다.
echo -n 'root' | base64
# cm9vdA==

echo -n 'dkagh1.' | base64
# ZGthZ2gxLg==
```

2단계: Secret YAML 파일 작성
1단계에서 얻은 인코딩된 값들을 사용하여 Secret 리소스를 정의합니다.

vi my-secret.yaml
YAML
```
# my-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: cm9vdA==
  password: ZGthZ2gxLg==
```

3단계: Secret을 마운트하는 Pod YAML 파일 작성
volumes와 volumeMounts를 사용하여, 위에서 만든 mysecret을 컨테이너의 /etc/securevol 경로에 마운트하도록 Pod를 정의합니다.

vi pod-mounts-secret.yaml
YAML
```
# pod-mounts-secret.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  volumes:
  - name: securevol
    secret:
      secretName: mysecret
  containers:
  - name: redis-container
    image: redis
    volumeMounts:
    - name: securevol
      mountPath: "/etc/securevol"
      readOnly: true
```

4단계: 리소스 생성 및 확인
작성한 YAML 파일들을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash
```
kubectl apply -f my-secret.yaml
kubectl apply -f pod-mounts-secret.yaml
kubectl wait --for=condition=Ready pod/mypod --timeout=120s
```

5단계: 마운트된 Secret 파일 확인
exec 명령으로 컨테이너에 접속하여, Secret의 데이터가 파일로 잘 생성되었는지 확인합니다.

마운트된 디렉터리 목록 확인:

Bash
```
kubectl exec -it mypod -- ls -l /etc/securevol
```
        ✨ 핵심 확인 포인트: username과 password라는 두 개의 파일이 보입니다. Secret의 **키(key)**가 파일 이름이 된 것을 확인할 수 있습니다.

파일 내용 확인:
각 파일의 내용을 확인하여 Base64 값이 자동으로 디코딩되었는지 확인합니다.

Bash
```
kubectl exec -it mypod -- cat /etc/securevol/username
```
        출력 예상: root

Bash
```
kubectl exec -it mypod -- cat /etc/securevol/password
```
        출력 예상: dkagh1.

6단계: 실습 리소스 정리
실습이 끝나면 생성했던 Pod와 Secret을 모두 삭제하여 환경을 정리합니다.

Bash
```
kubectl delete pod mypod
kubectl delete secret mysecret
```
        💡 핵심 개념: Secret의 생명주기
        Pod를 삭제해도 Secret은 자동으로 삭제되지 않습니다. Secret은 Pod와 독립적인 클러스터 레벨의 리소스이기 때문입니다. 따라서, 더 이상 필요 없는 Secret은 반드시 kubectl delete secret 명령으로 직접 삭제해주어야 합니다.

--------------------------------------------------------------------------

## 🚀 Secret 실습: 특정 경로에 파일 마운트 및 권한 설정
#### 🎯 목표: 시크릿 볼륨의 고급 옵션(items, defaultMode)을 사용하여, Secret의 특정 데이터만 선택하고, 원하는 하위 디렉터리에 원하는 파일 이름으로 마운트하며, 보안을 위해 파일 권한을 직접 설정하는 방법을 실습합니다.

💡 핵심 개념:

secret.items vs 전체 마운트:

        만약 items 필드를 사용하지 않으면, Secret에 포함된 모든 키가 파일로 마운트됩니다.

        items 필드를 사용하면 여기에 지정한 키만 선택적으로 마운트할 수 있어, 컨테이너에 불필요한 민감 정보가 노출되는 것을 방지할 수 있습니다.

items.path: 선택한 key의 내용을 저장할 파일의 경로와 이름을 지정합니다. mountPath를 기준으로 상대 경로를 사용하여 하위 디렉터리를 만들 수 있습니다.

secret.defaultMode: 마운트되는 파일에 적용할 **파일 권한(Permission)**을 8진수(Octal)로 설정합니다.

        💡 defaultMode 심화 학습:
        0400은 "파일 소유자만 읽기 전용"이라는 강력한 권한 설정입니다. Pod 내부에서 실행되는 프로세스의 사용자 ID가 파일의 소유자 ID(보통 root)와 일치해야 파일을 읽을 수 있습니다.
        이 설정은 root 권한으로 실행되는 컨테이너에는 유효하지만, 만약 비-root(non-root) 사용자로 실행되는 보안이 강화된 애플리케이션이라면 권한 부족으로 이 파일을 읽지 못할 수 있다는 점을 유의해야 합니다.

단계별 실습
1단계: Secret 데이터 수동 인코딩
먼저, Secret YAML 파일에 넣을 민감한 데이터를 Base64로 인코딩합니다.

Bash
```
echo -n 'root' | base64
# cm9vdA==

echo -n 'dkagh1.' | base64
# ZGthZ2gxLg==
```

2단계: Secret YAML 파일 작성
1단계에서 얻은 인코딩된 값들을 사용하여 Secret 리소스를 정의합니다.

vi my-secret.yaml
YAML
```
# my-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysecret
type: Opaque
data:
  username: cm9vdA==
  password: ZGthZ2gxLg==
```

3단계: 고급 마운트 옵션을 사용하는 Pod YAML 파일 작성
volumes 섹션에서 defaultMode와 items.path를 사용하여 Secret을 마운트하도록 Pod를 정의합니다.

vi pod-advanced-mount.yaml
YAML
```
# pod-advanced-mount.yaml
apiVersion: v1
kind: Pod
metadata:
  name: mypod
spec:
  containers:
  - name: redis-container
    image: redis
    volumeMounts:
    - name: secret-volume
      mountPath: "/etc/foo"
      readOnly: true
  volumes:
  - name: secret-volume
    secret:
      secretName: mysecret
      defaultMode: 0400
      items:
      - key: username
        path: my-group/my-username
      - key: password
        path: my-group/my-password
```

4단계: 리소스 생성 및 확인
작성한 YAML 파일들을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash
```
kubectl apply -f my-secret.yaml
kubectl apply -f pod-advanced-mount.yaml
kubectl wait --for=condition=Ready pod/mypod --timeout=120s
```

5단계: 마운트된 파일 경로 및 권한 확인
exec 명령으로 컨테이너에 접속하여, 파일이 지정된 경로와 권한으로 생성되었는지 확인합니다.

파일 내용 확인:
Bash
```
kubectl exec -it mypod -- cat /etc/foo/my-group/my-username

# 출력 예상: root
```

파일 권한 확인:

Bash
```
kubectl exec -it mypod -- ls -l /etc/foo/my-group/my-username
```
        ✨ 핵심 확인 포인트:
        파일 권한 부분이 -r--------으로 표시되어, 파일 소유자(owner)만 읽기(read) 권한을 가지고 있음을 확인할 수 있습니다.
        ```
        -r-------- 1 root root 4 Aug 21 03:30 /etc/foo/my-group/my-username
        ```

6단계: 실습 리소스 정리
Bash
```
kubectl delete pod mypod
kubectl delete secret mysecret
```
## 🚀 실무 Best Practice: Secrets Store CSI Driver
이 실습에서는 Secret을 쿠버네티스 내부에 저장하고 Pod에 마운트했지만, 보안을 극도로 중요시하는 운영 환경에서는 더 발전된 방식을 사용하기도 합니다.

Secrets Store CSI Driver는 AWS Secrets Manager, Azure Key Vault, HashiCorp Vault와 같은 외부 시크릿 관리 시스템에 저장된 비밀번호를, 쿠버네티스 Secret 리소스를 거치지 않고 Pod에 직접 파일로 마운트해주는 드라이버입니다.

이 방식을 사용하면 민감 정보가 쿠버네티스 데이터베이스(etcd)에 전혀 저장되지 않으므로, 중앙에서 시크릿을 관리하고 보안을 한 단계 더 강화할 수 있습니다.

--------------------------------------------------------------------------

## 🚀 Secret 실습: TLS 인증서를 Pod에 마운트하기
#### 🎯 목표: 자체 서명 TLS 인증서와 개인 키를 생성하고, 이를 kubernetes.io/tls 타입 시크릿으로 만들어 Pod에 안전하게 마운트하는 방법을 실습합니다.

💡 핵심 개념:

        TLS Secret: Ingress에서 HTTPS를 설정하거나, 웹 서버 Pod가 직접 HTTPS 통신을 제공할 때 필요한 **TLS 인증서(tls.crt)와 개인 키(tls.key)**를 저장하는 데 특화된 시크릿 타입입니다.

        자체 서명 인증서: 공인된 인증 기관(CA)이 아닌, 내가 직접 서명하여 만든 인증서입니다. 실제 서비스에서는 사용할 수 없지만, 개발 및 테스트 환경에서 HTTPS 기능을 구현할 때 유용하게 사용됩니다.

        볼륨 마운트: 생성된 TLS 시크릿은 볼륨으로 Pod에 마운트되며, 컨테이너 내부에는 tls.crt와 tls.key라는 표준화된 이름의 파일로 나타납니다.

단계별 실습
1단계: 준비 - 자체 서명 TLS 인증서 및 키 생성
openssl 명령어를 사용하여 시크릿으로 만들 개인 키와 인증서 파일을 생성합니다.

실습용 디렉터리 생성:
Bash
```
mkdir cert && cd cert
```

개인 키(Private Key) 생성:
Bash
```
openssl genrsa -out server.key 2048
```

인증서 서명 요청(CSR) 생성:
인증서에 포함될 정보를 담은 요청서를 만듭니다. CN(Common Name)에는 사용할 도메인 이름을 입력합니다.
Bash
```
openssl req -new -key server.key -out server.csr -subj "/CN=www.labs.local"
```

자체 서명 인증서(Certificate) 생성:
위에서 만든 개인 키와 CSR을 사용하여 365일간 유효한 자체 서명 인증서를 생성합니다.
Bash
```
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt
```
        이제 현재 디렉터리(cert)에 server.key(개인 키)와 server.crt(인증서) 파일이 생성되었습니다.

2단계: TLS 타입 Secret 생성
kubectl 명령어를 사용하여 1단계에서 만든 파일들로 tls 타입 시크릿을 생성합니다.

Bash
```
kubectl create secret tls my-tls-secret --cert=server.crt --key=server.key
```

생성된 시크릿의 내용을 확인하여 tls.crt와 tls.key 데이터가 포함되었는지 확인합니다.

Bash
```
kubectl get secret my-tls-secret -o yaml
```

3단계: TLS Secret을 마운트하는 Pod YAML 파일 작성
생성한 my-tls-secret을 볼륨으로 마운트하여 사용하는 Nginx Pod를 정의합니다.

vi nginx-tls-pod.yaml
YAML
```
# nginx-tls-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: web-nginx
spec:
  containers:
  - name: web-nginx-container
    image: nginx
    ports:
    - containerPort: 443 # HTTPS 포트
    volumeMounts:
    - name: cert-volume
      mountPath: "/etc/cert" # 인증서 파일을 마운트할 경로
      readOnly: true
  volumes:
  - name: cert-volume
    secret:
      secretName: my-tls-secret
      # 보안을 위해 파일 권한을 0400 (소유자 읽기 전용)으로 설정
      defaultMode: 0400
```

4단계: 리소스 생성 및 확인
작성한 YAML 파일을 클러스터에 적용하고, Pod가 Ready 상태가 될 때까지 기다립니다.

Bash
```
kubectl apply -f nginx-tls-pod.yaml
kubectl wait --for=condition=Ready pod/web-nginx --timeout=120s
```

5단계: 마운트된 인증서 파일 확인
exec 명령으로 컨테이너에 접속하여, 시크릿이 파일로 잘 생성되었는지 확인합니다.

마운트된 디렉터리 목록 및 권한 확인:
Bash
```
kubectl exec -it web-nginx -- ls -l /etc/cert
```

        ✨ 핵심 확인 포인트:

        원본 파일 이름(server.crt, server.key)과 상관없이, 쿠버네티스는 **표준 이름인 tls.crt와 tls.key**로 파일을 생성합니다.

        defaultMode: 0400 설정에 따라 파일 권한이 -r-------- (소유자 읽기 전용)으로 설정된 것을 볼 수 있습니다.

        ```
        total 8
        -r-------- 1 root root 1155 Aug 21 04:30 tls.crt
        -r-------- 1 root root 1704 Aug 21 04:30 tls.key
        ```

6단계: 실습 리소스 정리
실습이 끝나면 생성했던 Pod, Secret, 로컬 인증서 파일을 모두 삭제하여 환경을 정리합니다.

Bash
```
kubectl delete pod web-nginx
kubectl delete secret my-tls-secret
cd ..
rm -rf cert
```

--------------------------------------------------------------------------

## 🚀 종합 실습: Secret, ConfigMap, PV를 이용한 MySQL 배포
#### 🎯 목표: 실제 운영 환경과 유사하게, 민감 정보(Secret), 일반 설정(ConfigMap), 영속적 데이터 저장소(PersistentVolume)를 모두 분리하여 완전한 형태의 MySQL 데이터베이스를 배포하고 검증합니다.

💡 핵심 개념:

        Secret: 데이터베이스 비밀번호와 같은 민감 정보를 안전하게 관리합니다.

        ConfigMap: 데이터베이스 이름, 사용자 등 일반 설정 정보를 관리합니다.

        PersistentVolume (PV) & Claim (PVC): Pod가 재시작되어도 데이터가 사라지지 않도록 영속적인 저장 공간을 제공합니다.

        Deployment & Service: 애플리케이션(MySQL)을 안정적으로 실행하고, 클러스터 내외부에서 접근할 수 있도록 네트워크를 설정합니다.

1단계: 준비 - Secret 및 ConfigMap 생성
먼저, 애플리케이션에 주입할 민감 정보와 일반 설정을 생성합니다.

비밀번호 Base64 인코딩:
Bash
```
echo -n 'dkagh1.' | base64
# ZGthZ2gxLg==
```

Secret YAML 파일 작성 (mysql-secret.yaml):
vi mysql-secret.yaml
YAML
```
# mysql-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: mysql-secret
type: Opaque
data:
  # 'dkagh1.'을 인코딩한 값
  password: ZGthZ2gxLg==
  root_password: ZGthZ2gxLg==
```

ConfigMap YAML 파일 작성 (mysql-configmap.yaml):
vi mysql-configmap.yaml
YAML
```
# mysql-configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: mysql-config
data:
  host: "mysql-service" # Pod가 Service를 통해 자신을 찾을 때 사용할 이름
  port: "3306"
  database: "kdigital"
  user: "kevin"
```

리소스 생성:

Bash
```
kubectl apply -f mysql-secret.yaml
kubectl apply -f mysql-configmap.yaml
```

2단계: 영속적 스토리지(PV, PVC) 생성
데이터베이스 파일이 저장될 영속적인 공간을 준비합니다.

        ⚠️ 주의: 이 실습에서는 간단하게 노드의 로컬 경로를 사용하는 hostPath를 사용하지만, 실제 운영 환경에서는 NFS, Ceph 또는 클라우드 스토리지(EBS, GCS Disk 등)를 사용하는 것이 일반적입니다.

PV 및 PVC YAML 파일 작성 (mysql-storage.yaml):
vi mysql-storage.yaml
YAML
```
# mysql-storage.yaml
apiVersion: v1
kind: PersistentVolume
metadata:
  name: mysql-pv-volume
spec:
  storageClassName: manual # 수동으로 바인딩할 것임을 명시
  capacity:
    storage: 20Gi
  accessModes:
    - ReadWriteOnce
  hostPath:
    path: "/mnt/data" # 노드의 이 디렉토리를 사용 (미리 생성되어 있어야 함)
---
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: mysql-pv-claim
spec:
  storageClassName: manual
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 20Gi
```

리소스 생성 및 확인:
Bash
```
kubectl apply -f mysql-storage.yaml

# PV와 PVC의 STATUS가 'Bound'로 잘 연결되었는지 확인
kubectl get pv,pvc
```

3단계: MySQL Deployment 및 Service 배포
이제 앞에서 만든 Secret, ConfigMap, PVC를 모두 사용하는 MySQL Deployment를 배포합니다.

Deployment 및 Service YAML 파일 작성 (mysql-deployment.yaml):
vi mysql-deployment.yaml
YAML
```
# mysql-deployment.yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql-service
spec:
  selector:
    app: mysql
  ports:
  - port: 3306
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: mysql-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0.28
        ports:
        - containerPort: 3306
        env:
          # ConfigMap과 Secret에서 값을 가져와 환경 변수로 주입
        - name: MYSQL_DATABASE
          valueFrom: { configMapKeyRef: { name: mysql-config, key: database } }
        - name: MYSQL_USER
          valueFrom: { configMapKeyRef: { name: mysql-config, key: user } }
        - name: MYSQL_ROOT_PASSWORD
          valueFrom: { secretKeyRef: { name: mysql-secret, key: root_password } }
        - name: MYSQL_PASSWORD
          valueFrom: { secretKeyRef: { name: mysql-secret, key: password } }
        volumeMounts:
          # PVC를 컨테이너의 데이터 디렉터리에 마운트
        - name: mysql-persistent-storage
          mountPath: /var/lib/mysql
      volumes:
        # 사용할 PVC를 정의
      - name: mysql-persistent-storage
        persistentVolumeClaim:
          claimName: mysql-pv-claim
```

리소스 생성 및 확인:
Bash
```
kubectl apply -f mysql-deployment.yaml
kubectl wait --for=condition=Available deployment/mysql-deployment --timeout=300s
```

4단계: 최종 검증
배포된 MySQL에 접속하여 모든 설정이 올바르게 적용되었는지 확인합니다.

Pod 접속:
Bash
```
POD_NAME=$(kubectl get pods -l app=mysql -o jsonpath='{.items[0].metadata.name}')
kubectl exec -it $POD_NAME -- /bin/bash
```

데이터베이스 로그인 및 확인:

Bash
```
# --- 컨테이너 내부 쉘에서 실행 ---
# Secret에 저장된 root 비밀번호로 로그인
root@mysql-deployment-xxxx:/# mysql -uroot -p"$MYSQL_ROOT_PASSWORD"

# ConfigMap에 정의된 데이터베이스와 유저가 생성되었는지 확인
MariaDB [(none)]> SHOW DATABASES;
MariaDB [(none)]> SELECT user FROM mysql.user;
MariaDB [(none)]> exit;
```
        kdigital 데이터베이스와 kevin 유저가 보이면 성공입니다.

5단계: 실습 리소스 정리
실습이 끝나면 생성했던 모든 리소스를 삭제합니다.
Bash
```
kubectl delete -f mysql-deployment.yaml
kubectl delete -f mysql-storage.yaml
kubectl delete -f mysql-configmap.yaml
kubectl delete -f mysql-secret.yaml
```
