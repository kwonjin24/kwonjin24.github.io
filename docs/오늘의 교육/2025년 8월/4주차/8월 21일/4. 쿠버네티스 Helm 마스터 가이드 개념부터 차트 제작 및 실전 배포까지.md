---
layout: default
title: 쿠버네티스 Helm 마스터 가이드: 개념부터 차트 제작 및 실전 배포까지
parent: 8월 21일
nav_order: 5
---

# 2025년 8월 20일 교육 내용

# 쿠버네티스

📌 쿠버네티스 헬름(Helm) 완벽 정리
1. 헬름(Helm)이란 무엇인가?
헬름은 **쿠버네티스용 패키지 매니저(Package Manager)**입니다.

리눅스에서 yum이나 apt를, Python에서 pip를 사용하는 것처럼, 헬름은 쿠버네티스 애플리케이션을 손쉽게 설치하고 관리할 수 있도록 도와줍니다. 하나의 애플리케이션을 구성하는 수많은 YAML 파일들(Deployment, Service 등)을 **'차트(Chart)'**라는 패키지 하나로 묶어, 명령어 한 줄로 전체 애플리케이션을 설치, 업그레이드, 삭제할 수 있게 해줍니다.

2. 헬름(Helm)의 3가지 핵심 개념
1) 차트 (Chart): 쿠버네티스 애플리케이션 패키지
차트는 헬름으로 배포할 수 있는 애플리케이션 패키지이며, 다음과 같은 구조를 가집니다.

Chart.yaml: 차트의 이름, 버전 등 **차트의 정보(메타데이터)**가 담긴 파일.

values.yaml: 차트를 설치할 때 사용자가 변경할 수 있는 기본 설정값들을 모아둔 파일.

templates/: 실제 쿠버네티스 리소스의 YAML 템플릿 파일들이 들어있는 디렉터리. 이 템플릿들은 values.yaml의 값을 참조하여 최종 YAML을 생성합니다.

charts/: 이 차트가 의존하는 다른 차트(Sub-chart)들이 위치하는 디렉터리.

💡 values.yaml의 마법: 손쉬운 커스터마이징
헬름의 가장 강력한 기능 중 하나는 values.yaml을 통해 설정을 쉽게 변경하는 것입니다. 차트의 기본값을 그대로 사용하지 않고, 나만의 설정 파일로 덮어쓰거나 특정 값만 변경할 수 있습니다.

파일로 설정 덮어쓰기 (실무 표준):
dev-values.yaml, prod-values.yaml 처럼 환경별 설정 파일을 따로 만들어 관리합니다.

Bash

# prod-values.yaml 파일의 내용으로 my-app 차트를 설치
$ helm install my-release ./my-app -f prod-values.yaml
명령어로 특정 값 변경하기:
간단한 값 한두 개만 바꿀 때 유용합니다.

Bash

# replica 수를 3으로, 이미지 태그를 "latest"로 변경하여 설치
$ helm install my-release ./my-app --set replicaCount=3 --set image.tag=latest
2) 릴리스 (Release): 클러스터에 배포된 차트의 인스턴스
릴리스는 특정 차트를 쿠버네티스 클러스터에 **설치한 결과물(인스턴스)**입니다. 하나의 차트로 여러 개의 릴리스를 만들 수 있으며(예: dev-blog, prod-blog), 각 릴리스는 버전(Revision)이 기록되어 안전한 업그레이드와 롤백이 가능합니다.

3) 리포지토리 (Repository): 차트를 저장하고 공유하는 공간
리포지토리는 완성된 차트들을 저장하고 공유하는 온라인 창고입니다.

✨ 최신 트렌드: Artifact Hub
과거에는 stable, incubator와 같은 공식 헬름 리포지토리가 있었지만, 현재는 사용되지 않습니다. 대신, Artifact Hub가 전 세계의 공개 차트들을 검색하고 사용할 수 있는 중앙 허브 역할을 하고 있습니다. 필요한 차트(예: prometheus, mysql)가 있다면 Artifact Hub에서 먼저 찾아보는 것이 일반적입니다.

3. 헬름(Helm)을 사용하면 무엇이 좋은가?
복잡성 관리: 수십 개의 YAML 파일을 하나의 차트로 관리하여 배포가 단순해집니다.

쉬운 재사용 및 공유: 잘 만들어진 차트는 어떤 쿠버네티스 환경에서든 동일하게 배포할 수 있어 재사용성이 높습니다.

간단한 설정 변경: 사용자는 복잡한 템플릿을 건드릴 필요 없이, values.yaml 파일의 값만 수정하여 애플리케이션을 자신의 환경에 맞게 쉽게 커스터마이징할 수 있습니다.

안전한 버전 관리 및 롤백: helm upgrade와 helm rollback 명령어를 통해 애플리케이션의 라이프사이클을 훨씬 더 쉽고 안전하게 관리할 수 있습니다.

--------------------------------------------------------------------------

🚀 Helm 마스터하기: 설치, 배포부터 업그레이드와 롤백까지 (최종 완성본)
🎯 목표: Helm CLI를 설치하고, 차트의 기본 구조를 이해하며, 네임스페이스를 활용하여 애플리케이션을 배포, 업그레이드, 롤백하는 전체 라이프사이클을 실습합니다.

💡 핵심 개념:

차트 구조: 모든 Helm 차트는 Chart.yaml(정보), values.yaml(설정), templates/(쿠버네티스 리소스 양식)이라는 일관된 구조를 가집니다.

릴리스 관리: Helm은 install, upgrade, rollback 명령어를 통해 클러스터에 배포된 애플리케이션(릴리스)의 버전을 체계적으로 관리합니다.

네임스페이스: -n 또는 --namespace 옵션을 사용하여 특정 작업 공간에 애플리케이션을 격리하여 배포하는 것은 실무의 기본입니다.

단계별 실습
1단계: Helm 설치하기
Debian/Ubuntu 환경에서 apt를 사용하여 Helm을 설치하고 버전을 확인합니다.

Bash

$ curl https://baltocdn.com/helm/signing.asc | gpg --dearmor | sudo tee /usr/share/keyrings/helm.gpg > /dev/null
$ sudo apt-get install apt-transport-https --yes
$ echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/helm.gpg] https://baltocdn.com/helm/stable/debian/ all main" | sudo tee /etc/apt/sources.list.d/helm-stable-debian.list
$ sudo apt-get update
$ sudo apt-get install helm
$ helm version
2단계: Helm 리포지토리 설정하기
널리 사용되는 bitnami 리포지토리를 추가하고 최신 정보를 가져옵니다.

Bash

$ helm repo add bitnami https://charts.bitnami.com/bitnami
$ helm repo update
3단계: 차트 검색 및 구조 확인
nginx 차트를 검색하고, helm pull 명령어로 차트 파일을 직접 다운로드하여 그 내부 구조를 확인합니다.

Bash

# NGINX 차트 검색
$ helm search repo nginx

# 차트 파일 다운로드 (버전은 다를 수 있음)
$ helm pull bitnami/nginx --version 18.1.5

# 압축 해제 및 구조 확인
$ tar -zxvf nginx-18.1.5.tgz
$ ls -l nginx/
출력 예상: Chart.yaml, values.yaml, templates 디렉터리 등 표준 차트 구조를 직접 눈으로 확인할 수 있습니다.

4단계: 네임스페이스를 사용하여 차트 설치하기
애플리케이션을 격리할 web 네임스페이스를 생성하고, 해당 네임스페이스에 NGINX 차트를 설치합니다.

Bash

# 네임스페이스 생성
$ kubectl create namespace web

# 'web' 네임스페이스에 'webserver'라는 이름으로 릴리스 생성
$ helm install webserver bitnami/nginx -n web
5단계: 배포된 릴리스(Release) 확인하기
web 네임스페이스에 릴리스와 관련 리소스들이 잘 생성되었는지 확인합니다.

Bash

# 릴리스 목록 확인
$ helm list -n web

# 생성된 쿠버네티스 리소스 확인
$ kubectl get pods,svc -n web
6단계: 릴리스 업그레이드 및 롤백 (버전 관리)
배포된 애플리케이션의 설정을 변경(업그레이드)하고, 문제가 생겼을 때 이전 버전으로 되돌리는(롤백) 과정을 실습합니다.

업그레이드 (Upgrade):
helm upgrade 명령어로 webserver 릴리스의 서비스 타입을 NodePort로 변경해 봅시다.

Bash

$ helm upgrade webserver bitnami/nginx -n web --set service.type=NodePort

# 서비스 타입이 NodePort로 변경되었는지 확인
$ kubectl get svc -n web
릴리스 기록 확인 (History):
지금까지의 배포 기록을 확인합니다.

Bash

$ helm history webserver -n web
출력 예상: REVISION 1번(최초 설치)과 2번(업그레이드) 기록이 나타납니다.

롤백 (Rollback):
문제가 발생했다고 가정하고, 최초 설치 상태인 REVISION 1로 릴리스를 되돌립니다.

Bash

$ helm rollback webserver 1 -n web

# 서비스 타입이 다시 LoadBalancer (기본값)로 돌아왔는지 확인
$ kubectl get svc -n web
7단계: 실습 마무리 - 릴리스 및 네임스페이스 삭제하기
실습이 끝나면 생성했던 모든 리소스를 깨끗하게 정리합니다.

Bash

# 'web' 네임스페이스에 있는 'webserver' 릴리스 삭제
$ helm uninstall webserver -n web

# 'web' 네임스페이스 삭제
$ kubectl delete namespace web

--------------------------------------------------------------------------

🚀 Helm 실습: NodePort 서비스로 애플리케이션 외부에 노출하기 (최종 완성본)
🎯 목표: helm install --set 명령어를 사용하여 차트의 기본 설정값을 덮어쓰는 방법을 익힙니다. 특히, NGINX 애플리케이션을 NodePort 타입의 서비스로 배포하여 클러스터 외부에서 직접 접근하는 방법을 실습합니다.

💡 핵심 개념:

NodePort 서비스: 클러스터의 **모든 노드(Node)**에 특정 포트를 열어, 외부에서 http://<노드_IP>:<노드_포트> 주소로 서비스에 접근할 수 있게 해주는 서비스 타입입니다.

helm install --set <key>=<value>: values.yaml 파일을 직접 수정하지 않고, 설치 시점에 특정 설정값만 간편하게 변경할 수 있는 매우 유용한 명령어입니다.

💡 NodePort 심화 학습:

포트 범위 (30000–32767): 쿠버네티스는 시스템의 다른 잘 알려진 포트(Well-Known Ports)와의 충돌을 피하기 위해, 기본적으로 30000-32767 범위의 포트를 NodePort용으로 예약해 둡니다.

실무 주의사항: NodePort는 서비스를 외부에 노출하는 가장 간단한 방법이지만, 보안상의 이유와 포트 관리의 복잡성 때문에 주로 개발 및 테스트 환경에서 사용됩니다. 실제 운영 환경에서는 LoadBalancer나 Ingress를 사용하는 것이 일반적인 표준 방식입니다.

사전 탐색: values.yaml 구조 확인하기
--set 명령어로 어떤 값을 변경할 수 있는지 미리 확인하는 것은 매우 중요합니다. helm show values를 통해 bitnami/nginx 차트의 서비스 관련 설정 구조를 확인해 봅시다.

Bash

# service.nodePorts 관련 설정을 중심으로 위아래 3줄씩 함께 보기
$ helm show values bitnami/nginx | grep -C 3 nodePorts
✨ 핵심 확인 포인트:
아래와 같은 구조를 통해, 우리가 변경해야 할 값의 정확한 경로가 service.type과 service.nodePorts.http임을 미리 파악할 수 있습니다.

YAML

service:
  type: LoadBalancer
  ports:
    http: 80
  nodePorts:
    http: ""
    https: ""
실습 1: 자동 할당된 NodePort로 서비스 노출하기
차트 설치 및 service.type 변경:
--set 옵션을 사용하여 bitnami/nginx 차트의 기본 서비스 타입을 NodePort로 변경하여 설치합니다.

Bash

$ helm install webserver bitnami/nginx --set service.type=NodePort
서비스 확인 및 포트 번호 찾기:
생성된 서비스의 정보를 확인하여, 쿠버네티스가 자동으로 할당해 준 NodePort 번호를 찾습니다.

Bash

$ kubectl get svc webserver-nginx
PORT(S) 컬럼에서 3으로 시작하는 5자리 숫자가 외부에서 접속할 NodePort입니다. (예: 80:31395/TCP)

외부 접속 테스트:
아무 워커 노드의 IP와 위에서 확인한 NodePort를 사용하여 curl 또는 웹 브라우저로 접속합니다.

Bash

# <WORKER_NODE_IP>와 <NODE_PORT>는 자신의 환경에 맞게 변경
$ curl http://<WORKER_NODE_IP>:<NODE_PORT>
릴리스 삭제:

Bash

$ helm uninstall webserver
실습 2: 고정된 NodePort로 서비스 노출하기
이번에는 쿠버네티스가 포트를 자동 할당하는 대신, 우리가 원하는 특정 포트(30000)를 직접 지정하여 서비스를 노출합니다.

차트 설치 및 NodePort 직접 지정:
service.type과 함께, service.nodePorts.http 값을 --set 옵션으로 지정합니다.

Bash

$ helm install webserver bitnami/nginx --set service.type=NodePort --set service.nodePorts.http=30000
서비스 확인:
생성된 서비스의 NodePort가 30000번으로 정확히 할당되었는지 확인합니다.

Bash

$ kubectl get svc webserver-nginx
출력 예상: PORT(S) 컬럼에 80:30000/TCP라고 표시됩니다.

외부 접속 테스트:

Bash

$ curl http://<WORKER_NODE_IP>:30000
실습 마무리:

Bash

$ helm uninstall webserver

--------------------------------------------------------------------------

🚀 Helm 실습: values.yaml 파일로 배포 전략 마스터하기 (최종 완성본)
🎯 목표: helm show values를 통해 차트의 기본 설정을 추출하고, 환경별로 분리된 사용자 정의 values.yaml 파일을 사용하여 애플리케이션을 배포하는 실무적인 방법을 실습합니다.

💡 핵심 개념:

helm install -f <파일명>: -f 또는 --values 옵션으로 사용자 정의 설정 파일을 지정하여 차트를 설치하는 방식입니다.

values 적용 우선순위: Helm은 여러 설정 소스를 계층적으로 덮어씁니다. 이 우선순위를 이해하는 것이 매우 중요합니다.

--set (가장 높음): 커맨드 라인에서 직접 지정한 값.

-f로 지정한 values.yaml 파일 (중간): 사용자가 직접 만든 설정 파일.

차트 내부의 기본 values.yaml (가장 낮음): 차트에 포함된 기본값.

즉, 기본 설정을 파일로 관리하되, 테스트 시 특정 값 하나만 임시로 바꾸고 싶을 때 --set을 유용하게 사용할 수 있습니다.

실습 1: 기본 values.yaml 파일 커스터마이징
기본 values.yaml 파일 추출:
bitnami/nginx 차트의 기본 설정값 전체를 로컬 파일로 저장합니다.

Bash

$ helm show values bitnami/nginx > default_values.yaml
사용자 정의 values.yaml 파일 작성:
default_values.yaml을 복사하여, dev 환경을 위한 dev_values.yaml 파일을 만들고 아래와 같이 수정합니다.

Bash

$ cp default_values.yaml dev_values.yaml
$ vi dev_values.yaml
YAML

# dev_values.yaml 파일 내에서 service 섹션을 찾아 아래와 같이 수정

...
service:
  type: NodePort       # <-- 개발 환경을 위해 NodePort로 변경
  ports:
    http: 80
  nodePorts:
    http: "30080"      # <-- http 포트를 30080으로 직접 지정
...
사용자 정의 파일을 사용하여 차트 설치:
-f 옵션을 사용하여 우리가 수정한 dev_values.yaml 파일을 기준으로 차트를 설치합니다.

Bash

$ helm install dev-web -f dev_values.yaml bitnami/nginx
배포 결과 확인 및 접속 테스트:
서비스가 NodePort 타입으로, 포트가 30080으로 할당되었는지 확인하고 접속을 테스트합니다.

Bash

$ kubectl get svc dev-web-nginx
$ curl http://<WORKER_NODE_IP>:30080
릴리스 삭제:

Bash

$ helm uninstall dev-web
실습 2 (심화): 환경별 values.yaml 파일로 배포 관리하기
실제 운영 환경에서는 개발, 운영 등 환경별로 다른 설정 파일을 만들어 사용합니다.

환경별 values 파일 2개 작성:

prod_values.yaml (운영용): replica 수를 3개로 설정

YAML

# prod_values.yaml
replicaCount: 3
service:
  type: LoadBalancer
staging_values.yaml (스테이징용): replica 수를 1개로 설정

YAML

# staging_values.yaml
replicaCount: 1
service:
  type: ClusterIP
각 환경에 맞게 릴리스 배포:
-f 옵션을 사용하여 각 환경에 맞는 설정으로 릴리스를 배포합니다.

Bash

# 운영용 릴리스 배포
$ helm install prod-web -f prod_values.yaml bitnami/nginx

# 스테이징용 릴리스 배포
$ helm install staging-web -f staging_values.yaml bitnami/nginx
결과 확인:
helm list --all-namespaces 명령어로 두 개의 릴리스가 각기 다른 설정으로 배포되었는지 확인합니다.

✨ 실무 Best Practice: Git으로 values.yaml 관리하기
실무에서는 위에서 만든 dev_values.yaml, prod_values.yaml 같은 설정 파일들을 Git으로 버전 관리하는 것이 표준 방식입니다. 이를 GitOps의 기초라고 합니다.

변경 이력 추적: 누가, 언제, 어떤 설정을 변경했는지 모든 기록이 남습니다.

코드 리뷰: 인프라 설정 변경도 애플리케이션 코드처럼 동료의 리뷰를 받을 수 있어 안정성이 높아집니다.

손쉬운 롤백: 특정 설정 변경에 문제가 생겼을 때, Git에서 해당 변경사항을 되돌리고(git revert) 다시 배포하기만 하면 되므로 롤백이 매우 간편하고 안전합니다.

실습 마무리
실습이 끝나면 생성했던 모든 리소스를 삭제하여 환경을 정리합니다.

Bash

$ helm uninstall prod-web
$ helm uninstall staging-web
$ rm *.yaml

--------------------------------------------------------------------------

🚀 Helm 실습: 나만의 첫 번째 Helm Chart 만들기
🎯 목표: helm create 명령어로 차트의 기본 구조를 생성하고, kubectl --dry-run으로 리소스 템플릿을 만든 후, 직접 만든 로컬 차트를 클러스터에 배포하는 전체 과정을 실습합니다.

💡 핵심 개념:

helm create <chart-name>: 애플리케이션 배포에 필요한 표준 디렉터리와 파일들(Chart.yaml, values.yaml, templates/ 등)을 자동으로 생성해주는 명령어입니다.

templates/ 디렉터리: 이 차트가 배포할 쿠버네티스 리소스(Deployment, Service 등)의 YAML 템플릿 파일들을 저장하는 핵심 공간입니다.

helm lint: 차트를 설치하기 전에, 문법 오류나 권장 사항 위배 여부를 검사하는 '문법 검사기'입니다.

helm install <release-name> <chart-path>: 원격 리포지토리가 아닌, 내 컴퓨터에 있는 로컬 차트 디렉터리 경로를 지정하여 애플리케이션을 배포합니다.

단계별 실습
1단계: 새로운 Helm Chart 생성하기
helm create 명령어를 사용하여 web3tier라는 이름의 새로운 차트 골격(boilerplate)을 생성합니다.

Bash

# 'web3tier'라는 이름의 차트 디렉터리 생성
$ helm create web3tier

# 생성된 차트의 기본 파일 구조 확인
$ tree web3tier
✨ 결과: 아래 이미지와 같이 Chart.yaml, values.yaml, templates 디렉터리 등 Helm 차트의 표준 구조가 자동으로 생성된 것을 확인할 수 있습니다.

2단계: 템플릿 정리 및 생성
이번 실습에서는 가장 기본적인 Deployment와 Service만 사용할 것이므로, helm create가 만들어준 복잡한 기본 템플릿들을 정리하고 직접 만들어 보겠습니다.

기본 템플릿 파일 삭제:

Bash

$ rm -rf ~/web3tier/templates/tests/
$ rm -f ~/web3tier/templates/*.*
--dry-run으로 템플릿 생성:
kubectl의 --dry-run=client -o yaml 옵션은 리소스를 실제로 생성하지 않고 YAML 파일로 출력해주는 매우 유용한 기능입니다. 이를 활용해 Deployment와 Service 템플릿을 빠르게 생성합니다.

Bash

# deployment.yaml 생성
$ kubectl create deployment webserver --image=nginx --port=80 --dry-run=client -o yaml > ~/web3tier/templates/deployment.yaml

# service.yaml 생성
$ kubectl create service nodeport webserver --tcp=80:80 --dry-run=client -o yaml > ~/web3tier/templates/service.yaml
3단계: 차트 유효성 검사
차트를 설치하기 전에 helm lint 명령어로 문법적인 오류가 없는지 검사합니다.

Bash

$ helm lint ./web3tier
결과: 아래 이미지처럼 0 chart(s) failed 메시지가 나오면 성공입니다. (icon is recommended와 같은 정보(INFO) 메시지는 무시해도 됩니다.)

4단계: 로컬 차트 설치하기
이제 직접 만든 로컬 차트(web3tier)를 webserver라는 릴리스 이름으로 클러스터에 설치합니다.

Bash

$ helm install webserver ./web3tier
5단계: 배포 결과 확인
helm list와 kubectl 명령어로 릴리스와 관련 리소스들이 정상적으로 배포되었는지 확인합니다.

Bash

$ helm list
$ kubectl get pods,svc
결과: 아래 이미지처럼 webserver 릴리스가 deployed 상태이고, 관련 Pod와 Service가 정상적으로 Running 상태인 것을 확인할 수 있습니다.

6단계: 외부 접속 테스트
kubectl get svc로 확인된 NodePort를 사용하여, 워커 노드의 IP로 접속해 NGINX 환영 페이지가 보이는지 확인합니다.

Bash

# <WORKER_NODE_IP>와 <NODE_PORT>는 자신의 환경에 맞게 변경
$ curl http://<WORKER_NODE_IP>:<NODE_PORT>
결과: 웹 브라우저나 curl을 통해 아래와 같은 NGINX 페이지가 보이면 최종적으로 성공한 것입니다.

7단계: 실습 마무리
실습이 끝나면 생성했던 릴리스와 로컬 차트 디렉터리를 삭제하여 환경을 정리합니다.

Bash

$ helm uninstall webserver
$ rm -rf web3tier

--------------------------------------------------------------------------

🚀 Helm 실습: WordPress & NGINX 애플리케이션 배포하기
🎯 목표: helm search, helm pull 등 다양한 Helm 명령어를 사용하여 WordPress와 NGINX 같은 실제 애플리케이션 차트를 배포하고, values.yaml 파일을 수정하여 배포 설정을 커스터마이징하는 실무적인 방법을 익힙니다.

💡 핵심 개념:

helm pull: 원격 리포지토리에 있는 차트를 .tgz 압축 파일 형태로 로컬에 다운로드합니다. 이를 통해 차트의 내부 구조(templates, values.yaml 등)를 직접 확인하고 수정할 수 있습니다.

helm install -f <파일>: 사용자 정의 values.yaml 파일을 사용하여 차트를 설치하는 표준 방식입니다.

helm get manifest: 현재 클러스터에 배포된 릴리스가 어떤 YAML 내용으로 실행되고 있는지 직접 확인할 수 있는 강력한 디버깅 도구입니다.

실습 1: WordPress 차트 설치 및 관리
WordPress 차트 검색 및 다운로드:
bitnami 리포지토리에서 wordpress 차트를 검색하고, 로컬로 다운로드하여 압축을 해제합니다.

Bash

$ helm search repo wordpress
$ helm pull bitnami/wordpress
$ tar -zxvf wordpress-*.tgz
$ cd wordpress
차트 정보 확인:
show 명령어를 사용하여 차트의 설명서(README.md)와 변경 가능한 설정값(values.yaml)을 미리 확인합니다.

Bash

# 차트의 설명서 보기
$ helm show readme bitnami/wordpress | more

# 변경 가능한 모든 설정값 보기
$ helm show values bitnami/wordpress | more
사용자 설정값과 함께 WordPress 설치:
--set 옵션을 사용하여 WordPress 관리자 계정, 블로그 이름, 데이터 저장 공간 등 주요 설정값을 직접 지정하여 설치합니다.

Bash

$ helm install wordpress bitnami/wordpress \
  --set wordpressUsername=kevin \
  --set wordpressPassword=P@ssw0rd \
  --set wordpressBlogName="kdigital" \
  --set persistence.size=5Gi
릴리스 확인 및 삭제:
설치가 완료되면 helm list로 릴리스를 확인하고, 확인이 끝나면 helm uninstall로 정리합니다.

Bash

$ helm list
$ helm uninstall wordpress
실습 2: NGINX 차트 커스터마이징 및 배포
이번에는 차트를 로컬에 다운로드하고, values.yaml 파일을 직접 수정하여 배포하는 실무 방식을 실습합니다.

NGINX 차트 다운로드 및 준비:

Bash

$ helm pull bitnami/nginx
$ tar -zxvf nginx-*.tgz
$ cd nginx

# 기본 values.yaml을 수정용으로 복사
$ cp values.yaml my-values.yaml
my-values.yaml 파일 수정:
my-values.yaml 파일을 열어, 복제본(replica) 수를 3으로, 서비스 타입을 LoadBalancer로 변경하는 등 원하는 대로 설정을 수정합니다.

Bash

$ vi my-values.yaml
YAML

# my-values.yaml 예시
...
replicaCount: 3
...
service:
  type: LoadBalancer
...
수정한 설정 파일로 NGINX 설치:
-f 옵션으로 우리가 수정한 my-values.yaml 파일을 지정하여 차트를 설치합니다.

Bash

$ helm install nginx -f my-values.yaml .
.은 현재 디렉터리의 차트를 사용하겠다는 의미입니다.

배포 결과 확인:
릴리스 목록과 실제 생성된 쿠버네티스 리소스들을 확인합니다.

Bash

$ helm list
$ kubectl get deploy,svc,configmap
결과: 아래 이미지처럼 helm list로 릴리스를 확인하고, kubectl 명령어로 Deployment의 복제본 수가 3/3으로, Service 타입이 LoadBalancer로 생성되었는지 확인합니다.

배포된 Manifest 확인 (디버깅 팁):
helm get manifest 명령어를 사용하면, my-values.yaml의 설정값이 최종적으로 어떤 Kubernetes YAML로 변환되어 클러스터에 적용되었는지 직접 확인할 수 있습니다.

Bash

$ helm get manifest nginx
실습 마무리:
실습이 끝나면 생성했던 릴리스와 로컬 파일을 삭제하여 환경을 정리합니다.

Bash

$ helm uninstall nginx
$ cd ..
$ rm -rf nginx nginx-*.tgz