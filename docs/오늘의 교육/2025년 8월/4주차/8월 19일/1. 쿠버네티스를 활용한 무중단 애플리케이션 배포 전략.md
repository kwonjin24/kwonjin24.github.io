---
layout: default
title: 쿠버네티스를 활용한 무중단 애플리케이션 배포 전략
parent: 8월 19일
nav_order: 2
---

# 2025년 8월 19일 교육 내용

# 쿠버네티스

blue-green 배포

# 🚀 블루/그린 배포 실습: 무중단 트래픽 전환 마스터하기
## 🎯 목표: 서비스 중단 없이 신규 버전의 애플리케이션을 배포하고, 단 한 번의 명령으로 사용자 트래픽을 신규 버전으로 즉시 전환하는 블루/그린 배포 전략을 이해하고 실습합니다.

## 💡 핵심 개념: 블루/그린 배포는 동일한 환경 두 개를 구성하여 안정성을 극대화하는 전략입니다.

블루 (Blue): 현재 사용자들이 접속하고 있는 기존 버전의 환경입니다.
그린 (Green): 새로 배포할 신규 버전의 환경입니다.

라우터 (Router): 사용자 트래픽을 블루 또는 그린으로 보내는 역할을 하며, 쿠버네티스에서는 **서비스(Service)**가 이 역할을 담당합니다.

배포 흐름: 기존 버전(Blue)이 운영 중인 상태에서, 사용자 트래픽과 완전히 분리된 신규 버전(Green) 환경을 배포합니다.

Green 환경이 정상적으로 동작하는지 내부적으로 충분히 테스트합니다.

모든 준비가 끝나면, 서비스의 Selector 설정을 변경하여 사용자 트래픽을 Blue에서 Green으로 한 번에 전환합니다.

문제가 발생하면 즉시 Selector를 다시 Blue로 변경하여 신속하게 롤백할 수 있습니다.

단계별 실습
1) 'Blue' 환경 배포 (기존 버전)
먼저, 현재 운영 중인 nginx:1.14 버전의 'Blue' 환경을 배포합니다. 서비스는 color=blue 라벨을 가진 Pod로 트래픽을 보내도록 설정합니다.

vi blue-env.yaml
YAML
```
# blue-env.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment-blue
spec:
  replicas: 4
  selector:
    matchLabels:
      app: test-pod
      color: blue
  template:
    metadata:
      labels:
        app: test-pod
        color: blue
    spec:
      containers:
      - name: test-pod
        image: nginx:1.14
        ports:
        - containerPort: 8080
---
apiVersion: v1
kind: Service
metadata:
  name: test-service
spec:
  ports:
  - port: 80
    targetPort: 8080
  selector:
    app: test-pod
    color: blue # <-- 현재 트래픽은 'blue'로 향함
```

Blue 환경 생성 및 확인:
Bash
```
kubectl apply -f blue-env.yaml

서비스의 Selector가 'color=blue'로 설정된 것을 확인
kubectl describe service test-service
```

2) 'Green' 환경 배포 (신규 버전)
이제 사용자 트래픽에 영향을 주지 않고, nginx:1.17 버전의 'Green' 환경을 배포합니다.

vi green-env.yaml
YAML
```
apiVersion: apps/v1
kind: Deployment
metadata:
  name: test-deployment-green
spec:
  replicas: 4
  selector:
    matchLabels:
      app: test-pod
      color: green
  template:
    metadata:
      labels:
        app: test-pod
        color: green
    spec:
      containers:
      - name: test-pod
        image: nginx:1.17
        ports:
        - containerPort: 8080
```

Green 환경 생성 및 확인:
Bash
```
kubectl apply -f green-env.yaml

# Blue와 Green Pod가 모두 실행 중인지 확인
kubectl get pods --show-labels
```
        ✨ 핵심 포인트: 이 시점에는 Blue와 Green Pod가 모두 존재하지만, test-service는 여전히 color=blue 라벨을 가진 Pod로만 트래픽을 보내고 있습니다.

3) 트래픽 전환 (Blue → Green)
Green 환경이 준비되었으므로, 이제 서비스의 Selector를 변경하여 사용자 트래픽을 Green 환경으로 즉시 전환합니다.

서비스 설정을 변경하기 위한 patch-green.yaml 파일을 생성합니다.
vi patch-green.yaml
YAML
```
spec:
  selector:
    color: green # 트래픽 대상을 'green'으로 변경
```

patch 명령어로 서비스 업데이트:kubectl patch 명령어는 실행 중인 리소스의 특정 부분만 수정할 때 매우 유용합니다.
Bash
```
kubectl patch service test-service --patch-file patch-green.yaml
```

전환 결과 확인:
서비스의 Selector가 color=green으로 변경되고, Endpoints(실제 트래픽이 전달되는 Pod IP)가 Green Pod들의 IP로 바뀐 것을 확인합니다.
Bash
```
kubectl describe service test-service
```

4) 이전 환경 정리
Green 환경이 안정적으로 동작하는 것을 확인한 후, 더 이상 필요 없는 Blue 환경을 삭제합니다.
Bash
```
kubectl delete deployment test-deployment-blue
```

5) 실습 마무리
남아있는 Green 환경과 서비스를 모두 삭제하여 실습 환경을 정리합니다.
Bash
```
kubectl delete deployment test-deployment-green
kubectl delete service test-service
```

--------------------------------------------------------------------------

# 🚀 카나리 배포 실습 (심화편): 명확한 버전 확인 및 고급 롤백 전략
## 🎯 목표: ConfigMap을 이용해 버전별 응답을 명확히 구분하고, Stable 버전 업데이트 중 문제 발생 시 rollout undo를 통한 롤백까지 경험하며, 실무에 가장 가까운 카나리 배포 및 운영 전략을 실습합니다.

## 💡 핵심 개념: 이전과 동일하게 Stable, Canary, Service의 관계를 기반으로 하되, 이번 실습에서는 버전별 응답을 명확히 구분하여 테스트 효과를 극대화합니다.

ConfigMap: 애플리케이션의 설정 데이터를 Pod와 분리하여 관리하는 쿠버네티스 오브젝트입니다. 여기서는 버전별 index.html 파일의 내용을 담는 용도로 사용합니다.

📌 실무 팁: 정밀한 트래픽 제어
이번 실습에서는 Pod의 replicas 개수로 트래픽 비율(예: 4:1)을 조절합니다. 이 방법은 개념을 이해하기에 아주 좋습니다. 하지만 실제 운영 환경에서는 Ingress Controller(Nginx, Traefik 등)나 서비스 메시(Istio, Linkerd 등)를 사용하여 weight 값을 설정하는 방식으로, "Stable 90%, Canary 10%"처럼 훨씬 더 정밀하게 트래픽을 제어하는 것이 일반적입니다.

단계별 실습
1) '안정(Stable)' 환경 배포 (feat. ConfigMap)
nginx:1.14 버전의 Deployment와 Service, 그리고 "Hello from Stable v1.14" 메시지를 담은 index.html을 제공할 ConfigMap을 함께 배포합니다.

vi stable-env.yaml
YAML
```
# stable-env.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: stable-html
data:
  index.html: "<h1>Hello from Stable v1.14</h1>"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 4
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
        version: "1.14"
    spec:
      containers:
      - name: nginx
        image: nginx:1.14
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html # Nginx의 html 디렉터리에 볼륨 마운트
      volumes:
      - name: html
        configMap:
          name: stable-html # 위에서 생성한 ConfigMap을 볼륨으로 사용
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

Stable 환경 생성 및 확인:

Bash
```
kubectl apply -f stable-env.yaml
```

2) '카나리(Canary)' 환경 배포 (feat. ConfigMap)
nginx:1.15 버전의 Canary Deployment와 "Hello from Canary v1.15" 메시지를 담은 별도의 ConfigMap을 배포합니다.

canary-env.yaml

YAML
```
# canary-env.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: canary-html
data:
  index.html: "<h1>Hello from Canary v1.15</h1>"
---
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-canary-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
      version: canary
  template:
    metadata:
      labels:
        app: nginx
        version: canary
    spec:
      containers:
      - name: nginx
        image: nginx:1.15
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html
        configMap:
          name: canary-html
```

Canary 환경 생성 및 확인:
Bash
```
kubectl apply -f canary-env.yaml
kubectl get pods --show-labels
```

3) 트래픽 분산 실제 확인 (명확한 버전 구분)
임시 Pod에서 curl을 반복 실행하여 두 가지 다른 응답("...Stable..." 또는 "...Canary...")이 나타나는 것을 직접 확인합니다.
Bash
```
# 임시 busybox Pod를 실행하여 셸에 접속합니다.
kubectl run tmp --rm -it --image=busybox --restart=Never -- sh

# Pod 셸 내부에서 아래 명령어를 실행합니다.
# 약 5번 중 1번 꼴로 "Hello from Canary v1.15" 메시지가 출력되는 것을 확인하세요.
while true; do curl -s http://nginx-service | grep Hello; sleep 1; done
```
        확인이 끝나면 exit를 입력하여 임시 Pod를 빠져나옵니다.

4) 시나리오 분기: 성공 vs 실패
4-1. 성공 시나리오: 전체 롤아웃 및 고급 롤백 전략
A. 전체 롤아웃 (Stable 버전 업데이트)
stable-env.yaml 파일의 Deployment 부분을 nginx:1.15 이미지와 version: "1.15" 라벨로 업데이트하고, volumeMounts가 canary-html ConfigMap을 바라보도록 수정합니다.

vi stable-env.yaml
YAML
```
# ConfigMap은 Stable 버전을 업데이트할 때 직접 수정하지는 않지만,
# 파일 내에 함께 정의되어 있으므로 그대로 둡니다.
apiVersion: v1
kind: ConfigMap
metadata:
  name: stable-html
data:
  index.html: "<h1>Hello from Stable v1.14</h1>"
---
# Deployment는 신규 버전(1.15)의 내용으로 업데이트합니다.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 4
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
        version: "1.15"         # <-- 변경된 부분
    spec:
      containers:
      - name: nginx
        image: nginx:1.15       # <-- 변경된 부분
        ports:
        - containerPort: 80
        volumeMounts:
        - name: html
          mountPath: /usr/share/nginx/html
      volumes:
      - name: html
        configMap:
          name: canary-html     # <-- 변경된 부분
---
# Service는 변경할 필요 없이 그대로 둡니다.
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
  - protocol: TCP
    port: 80
    targetPort: 80
```

```
kubectl apply -f stable-env.yaml
```

🚨 비상 상황: Stable 업데이트 중 문제 발생 시 롤백하기
만약 apply 명령으로 Stable 버전을 업데이트하는 과정에서 문제가 발생했다면, 다음 명령어로 즉시 이전 버전으로 되돌릴 수 있습니다.
Bash
```
# 현재 배포의 리비전(변경 이력) 확인
kubectl rollout history deployment/nginx-deployment

# 가장 최신 리비전의 변경을 취소하고 이전 버전으로 되돌리기
kubectl rollout undo deployment/nginx-deployment
```

B. 카나리 환경 정리
전체 롤아웃이 성공적으로 완료되었다면, 테스트용 Canary 환경을 삭제합니다.
Bash
```
kubectl delete -f canary-env.yaml
```

4-2. 실패 시나리오: 카나리 즉시 롤백
Canary 테스트 중 버그가 발견되어 배포를 중단하는 시나리오입니다. 이전과 동일하게 Canary 환경만 삭제하면 즉시 롤백이 완료됩니다.
Bash
```
kubectl delete -f canary-env.yaml
```

5) 실습 마무리
실습에 사용된 모든 리소스를 삭제합니다. 아래 명령어는 stable-env.yaml 파일에 정의된 Stable Deployment, Service, ConfigMap을 모두 삭제합니다.

Bash
```
kubectl delete -f stable-env.yaml
```

