---
layout: default
title: 
parent: 8월 25일
nav_order: 2
---

# 2025년 8월 25일 교육 내용

# CI/CD

CI/CD는 소프트웨어 개발의 **자동화된 파이프라인(Pipeline)**을 구축하는 핵심 방법론입니다. 이는 개발과 운영 프로세스를 통합하는 DevOps 문화의 핵심 실천 방법입니다.

CI/CD는 다음 두 가지 주요 단계로 구성됩니다.

1. CI: 지속적 통합 (Continuous Integration) 🔄
이 단계는 개발자 측면의 자동화를 담당합니다.

목표: 코드 변경 사항을 자주 병합하고 테스트하여 통합 문제를 빠르게 발견하고 해결하는 것입니다.

작동 방식:

코드 커밋: 개발자가 코드를 공유 저장소(예: Git)에 푸시합니다.

자동 빌드: CI 서버(예: 젠킨스, GitLab CI)가 이 코드를 감지하고 실행 가능한 파일로 **자동으로 빌드(Compile)**합니다.

자동 테스트: 빌드가 성공하면, 미리 작성된 단위 테스트, 통합 테스트 등을 자동으로 실행하여 코드가 정상 작동하는지 검증합니다.

효과: 통합 과정에서 발생하는 충돌이나 버그를 초기에 발견하여 개발 비용과 시간을 절감하고 코드 품질을 안정적으로 유지할 수 있습니다.

2. CD: 지속적 배포/제공 (Continuous Delivery/Deployment) 🚀
이 단계는 운영 측면의 자동화를 담당합니다. CI를 통과한 코드를 사용자에게 제공하는 환경으로 가져가는 과정입니다.

CD는 두 가지 다른 개념을 포함합니다.

A. 지속적 서비스 제공 (Continuous Delivery)
CI를 통과하여 테스트가 완료된 코드를 수동으로 배포할 수 있는 환경(예: 스테이징 서버)에 **자동으로 준비(Ready)**해 둡니다.

최종 운영 배포는 수동으로 이루어집니다. (운영자가 '배포' 버튼을 클릭하는 행위)

B. 지속적 배포 (Continuous Deployment)
CI/CD 파이프라인의 모든 자동화 테스트를 통과하면, 사람의 개입 없이 코드가 곧바로 **실제 사용자에게 서비스되는 운영 환경(Production)**으로 자동 배포됩니다.

가장 높은 수준의 자동화로, 테스트가 완벽하다는 신뢰가 있을 때 채택됩니다.

CI/CD의 최종적인 이점
결론적으로 CI/CD를 도입하면 얻는 가장 큰 이점은 다음과 같습니다.

빠른 릴리즈 주기: 새로운 기능이나 버그 수정을 몇 시간, 혹은 몇 분 만에 사용자에게 제공할 수 있습니다.

높은 안정성: 배포 과정의 자동화와 엄격한 테스트 덕분에 수동 배포 오류가 사라지고 시스템 안정성이 높아집니다.

위험 최소화: 코드 변경 단위가 작고 잦기 때문에, 문제가 발생해도 원인을 찾고 롤백(이전 버전으로 되돌리기)하기가 쉽습니다.

--------------------------------------------------------------------------

# DevOps

데브옵스(DevOps)는 **Development(개발)**와 **Operations(운영)**의 합성어입니다.

단순히 특정 기술이나 도구를 의미하는 것이 아니라, 소프트웨어 개발과 운영을 통합하여 더 빠르고 안정적으로 서비스를 제공하기 위한 문화적 철학, 일련의 관행, 그리고 자동화된 도구의 집합을 포괄하는 개념입니다.

1. 왜 DevOps가 필요한가요? 🤔
전통적인 IT 환경에서는 개발팀과 운영팀이 서로 독립적으로 일하는 사일로(Silo) 구조였습니다.

| 팀 | 주요 목표|
|---|---|
| 개발팀 | 새로운 기능을 빠르게 만들고 자주 업데이트하는 것 |
| 운영팀 | 시스템의 안정성과 보안을 유지하는 것 |

이러한 목표의 차이 때문에 개발팀이 코드를 운영팀에 넘길 때 병목 현상과 갈등이 자주 발생했습니다. DevOps는 이 두 팀 간의 장벽을 허물고 협업, 소통, 그리고 자동화를 극대화하여 전체 프로세스를 효율적으로 만드는 것을 목표로 합니다.

2. DevOps의 3가지 핵심 요소
DevOps는 다음 세 가지 주요 요소로 구성됩니다.

문화 (Culture): 개발, 운영, 보안 등 모든 관련 팀이 책임을 공유하고 지속적인 협업을 하는 조직 문화를 말합니다. 이는 신뢰를 구축하고 빠른 피드백 루프를 만드는 데 중요합니다.

프로세스 (Practices): **CI/CD(지속적 통합/지속적 배포)**와 같은 자동화된 작업 방식을 적용합니다. 이를 통해 코드 변경 사항이 빌드, 테스트, 배포되는 과정을 매끄럽게 만듭니다.

도구 (Tools): 이러한 프로세스를 자동화하고 관리하기 위해 다양한 도구가 사용됩니다.

코드 관리: Git, GitHub, GitLab

CI/CD: Jenkins, GitLab CI, CircleCI

컨테이너 및 오케스트레이션: Docker, Kubernetes

모니터링: Prometheus, Grafana

3. CI/CD는 DevOps의 핵심 실천 방법입니다. 🔄🚀
CI(지속적 통합): 개발자들이 작성한 코드를 자주 병합하고 자동으로 빌드, 테스트하여 통합 문제를 초기에 발견합니다.

CD(지속적 배포/제공): CI를 통과한 코드를 실제 사용자에게 배포하는 과정을 자동화합니다. 사람의 수동 개입 없이 자동으로 배포되거나, 수동으로 '클릭'만 하면 배포될 수 있도록 준비해 둡니다.

결론적으로, DevOps는 사람, 프로세스, 기술을 결합하여 소프트웨어를 더 자주, 더 빠르고, 더 안정적으로 출시하고 운영하는 것을 목표로 하는 현대적인 소프트웨어 개발 방식입니다.

--------------------------------------------------------------------------

마이크로서비스 아키텍처 (MSA) 란? 🤔
마이크로서비스 아키텍처(Microservice Architecture, MSA)는 하나의 큰 애플리케이션을 여러 개의 작은 서비스 단위로 나누어 개발하고 배포하는 방식을 말합니다. 여기서 각 서비스는 독립적으로 배포 및 확장이 가능하며, 자체 데이터베이스를 가질 수도 있습니다. 이는 전통적인 **모놀리식 아키텍처(Monolithic Architecture)**가 가진 문제점들을 해결하기 위해 등장했습니다.


모놀리식 아키텍처와의 비교
이해를 돕기 위해 전통적인 모놀리식 아키텍처와 비교해 보겠습니다.

| 구분 | 모놀리식 아키텍처 (Monolithic) | 마이크로서비스 아키텍처 (MSA) |
| :--- | :--- | :--- |
| **구조** | 하나의 큰 덩어리로 구성된 애플리케이션 | 기능별로 잘게 쪼개진 독립적인 서비스들의 묶음 |
| **개발** | 모든 개발자가 하나의 코드베이스에서 작업 | 각 팀이 맡은 서비스를 독립적으로 개발 |
| **배포** | 작은 수정에도 전체 애플리케이션을 다시 빌드하고 배포 | 변경된 서비스만 독립적으로 배포 가능 |
| **확장** | 특정 기능에 부하가 몰려도 전체 애플리케이션을 확장해야 함 | 부하가 발생하는 특정 서비스만 선택적으로 확장 가능 |
| **기술** | 전체가 하나의 기술 스택으로 통일 | 각 서비스에 가장 적합한 기술(언어, 프레임워크 등)을 자유롭게 선택 |
| **장애** | 하나의 기능 장애가 전체 시스템의 장애로 이어질 수 있음 | 특정 서비스의 장애가 다른 서비스에 미치는 영향이 적음 |
마크다운 표 사용 팁

마이크로서비스의 핵심 특징 및 장점 👍
독립적인 배포 (Independent Deployment): 각 서비스는 독립적으로 개발되고 배포될 수 있어 **빠르고 지속적인 배포(CI/CD)**가 용이합니다. 이로 인해 변경 사항을 시장에 더 빠르게 출시할 수 있습니다.

유연한 확장성 (Scalability): 사용자의 요청이 많은 특정 서비스(예: 로그인, 결제)만 선택적으로 확장(스케일 아웃)할 수 있어 자원을 효율적으로 사용할 수 있습니다.

기술의 다양성 (Polyglot): 각 서비스의 특성에 맞는 최적의 프로그래밍 언어, 데이터베이스, 프레임워크를 자유롭게 선택하여 적용할 수 있습니다.

회복탄력성 (Resilience): 특정 서비스에 장애가 발생하더라도 전체 시스템이 중단되지 않고, 해당 기능을 제외한 다른 서비스는 정상적으로 동작할 수 있습니다.

팀의 자율성 (Decentralized Governance): 서비스를 담당하는 소규모 팀이 기술 선택부터 개발, 배포, 운영까지 모든 권한을 가지고 자율적으로 일할 수 있어 생산성이 향상됩니다.

마이크로서비스의 단점 및 고려사항 👎
복잡성 증가 (Complexity): 서비스가 분산되어 있어 전체 시스템의 구조를 파악하기 어렵고, 서비스 간의 통신 방식(API 등)을 관리해야 하는 복잡성이 따릅니다.

데이터 분산 (Data Consistency): 각 서비스가 자체 데이터베이스를 가질 경우, 여러 서비스에 걸친 트랜잭션을 처리하고 데이터의 일관성을 유지하는 것이 매우 어렵습니다.

테스트의 어려움 (Testing Complexity): 전체 시스템을 테스트하려면 여러 서비스들의 상호작용을 모두 고려해야 하므로 테스트가 복잡해집니다.

운영 및 관리 비용 (Operational Overhead): 관리해야 할 서비스, 서버, 데이터베이스의 수가 많아져 배포, 모니터링, 로깅 등의 운영 부담이 증가합니다.

언제 마이크로서비스를 사용해야 할까?
마이크로서비스는 모든 프로젝트에 적합한 만병통치약은 아닙니다. 일반적으로 다음과 같은 경우에 도입을 고려해 볼 수 있습니다.

대규모의 복잡한 애플리케이션: 시스템이 너무 커서 하나의 팀이 관리하기 어렵고, 기능별로 분리가 필요한 경우

빠른 개발 및 배포 속도가 중요한 경우: 시장의 요구에 신속하게 대응해야 하는 비즈니스 환경

다양한 기술 스택을 활용하고 싶은 경우: 각 기능의 특성에 맞는 최적의 기술을 도입하고자 할 때

높은 수준의 확장성과 안정성이 요구되는 경우: 특정 기능에 트래픽이 몰리거나, 일부 장애가 전체 시스템에 영향을 미치면 안 되는 서비스

반면에, 소규모 프로젝트나 명확한 비즈니스 요구사항이 정해지지 않은 초기 단계에서는 오히려 모놀리식 아키텍처로 시작하는 것이 더 빠르고 효율적일 수 있습니다.

--------------------------------------------------------------------------

서버리스(Serverless)가 뭔가요? ☁️
"서버가 없다"는 뜻이 아니라, 개발자가 서버를 직접 관리할 필요가 없는 클라우드 컴퓨팅 모델을 의미합니다. 물리적인 서버는 클라우드 제공업체(AWS, Google Cloud, Microsoft Azure 등)가 알아서 관리하고, 개발자는 오직 자신의 코드(함수)만 작성하여 실행하면 됩니다.

수도 요금을 생각하면 이해하기 쉽습니다. 집에서 물을 쓰기 위해 직접 우물을 파고 펌프를 관리할 필요 없이, 필요할 때 수도꼭지를 틀어 사용한 만큼만 요금을 내는 것과 같은 원리입니다. 서버리스도 코드가 실행될 때만 자원을 할당받고, 사용한 만큼만 비용을 지불하는 방식입니다.

서버리스의 핵심 특징
서버 관리 불필요: 서버의 설치, 설정, 업데이트, 보안, 확장 등 귀찮고 복잡한 작업을 클라우드 제공업체가 모두 담당합니다. 개발자는 비즈니스 로직 개발에만 집중할 수 있습니다.

이벤트 기반 실행 (Event-Driven): 코드가 항상 실행 대기 상태인 것이 아니라, 특정 이벤트가 발생했을 때만 자동으로 실행됩니다. 예를 들어, 사용자가 이미지를 업로드했을 때(이벤트) 이미지 사이즈를 변경하는 코드(함수)가 실행되는 식입니다.

사용한 만큼만 지불 (Pay-per-use): 코드가 실행된 시간(밀리초 단위)과 사용된 메모리만큼만 비용을 지불합니다. 코드가 실행되지 않을 때는 비용이 거의 발생하지 않아 매우 경제적입니다.

자동 확장 및 축소 (Auto-Scaling): 사용자의 요청이 갑자기 급증해도 클라우드 제공업체가 알아서 서버 자원을 늘려주고, 요청이 줄어들면 자원을 다시 회수합니다. 트래픽 예측이나 서버 증설에 대한 걱정이 없습니다.

주요 개념: FaaS와 BaaS
서버리스는 크게 두 가지 서비스 모델로 나뉩니다.

FaaS (Function as a Service, 서비스형 함수): 서버리스의 핵심 모델로, 개발자가 작성한 함수(코드 조각)를 특정 이벤트에 대한 응답으로 실행하는 서비스입니다. (예: AWS Lambda, Google Cloud Functions)

BaaS (Backend as a Service, 서비스형 백엔드): 애플리케이션 개발에 필요한 백엔드 기능들(사용자 인증, 데이터베이스, 스토리지 등)을 API 형태로 제공하여 개발자가 직접 서버를 개발하지 않고도 클라이언트(웹, 앱)를 만들 수 있게 해주는 서비스입니다. (예: Google Firebase)

장점 👍과 단점 👎
| 장점 | 단점 |
|---|---\
| 비용 효율성: 유휴 시간 없이 실행된 만큼만 비용을 내므로 비용 절감 효과가 큽니다. | 콜드 스타트(Cold Start): 오랫동안 호출되지 않은 함수는 처음 실행될 때 약간의 지연(latency)이 발생할 수 있습니다. |
| 생산성 향상: 인프라 관리에 드는 시간을 줄이고 핵심 비즈니스 로직 개발에 집중할 수 있습니다. | 벤더 종속성(Vendor Lock-in): 특정 클라우드 제공업체의 서비스에 맞춰 개발되므로, 다른 업체로 이전하기가 어려울 수 있습니다. |
| 뛰어난 확장성: 트래픽 변화에 따라 자동으로 자원이 조절되므로 유연한 대처가 가능합니다.	| 제한적인 실행 환경: 실행 시간, 메모리 사용량 등에 제한이 있어 장시간 실행되는 무거운 작업에는 부적합할 수 있습니다. |
| 빠른 배포 및 업데이트: 기능(함수) 단위로 배포가 이루어져 빠르고 간편합니다. | 	디버깅 및 모니터링의 복잡성: 분산된 환경이라 전체적인 흐름을 파악하고 문제를 추적하기가 상대적으로 어렵습니다. |

언제 사용할까요?
서버리스는 다음과 같은 경우에 특히 유용합니다.

예측 불가능한 트래픽을 처리해야 하는 서비스: 이벤트 티켓팅, 실시간 투표 등

이미지/동영상 처리: 파일이 업로드되면 썸네일을 생성하거나 인코딩하는 작업

챗봇 및 IoT 백엔드: 수많은 기기로부터 들어오는 데이터를 실시간으로 처리

주기적으로 실행되는 배치(Batch) 작업: 매일 밤 데이터를 수집하여 보고서를 생성하는 작업

빠르게 프로토타입을 만들어야 하는 스타트업

