---
layout: default
title: kubectl을 활용한 쿠버네티스 기초 실습
parent: 8월 13일
nav_order: 2
---

# 2025년 8월 13일 교육 내용

# 쿠버네티스 

쿠버네티스 자원 정리: 네임스페이스와 서비스
말씀하신 내용을 바탕으로 쿠버네티스의 핵심 개념들을 정리해 드리겠습니다. 이는 쿠버네티스 클러스터에서 애플리케이션을 배포하고 접근하는 기본 절차와 관련이 있습니다.

## 1) 네임스페이스 (Namespace)
네임스페이스는 쿠버네티스 클러스터의 자원들을 논리적으로 분리하여 관리하는 가상의 공간입니다.

역할: 여러 팀이나 환경(개발, 운영)을 분리하여 자원 간의 충돌을 막고, 효율적인 권한 관리를 가능하게 합니다.

확인 방법: kubectl get ns 명령어로 현재 클러스터에 존재하는 네임스페이스 목록을 확인할 수 있습니다.

## 2) 서비스 (Service)
서비스는 파드(Pod)에 안정적인 네트워크 연결을 제공하여 외부에서 애플리케이션에 접근할 수 있도록 해주는 핵심 자원입니다. 서비스의 종류에 따라 접근 방식이 달라집니다.

ClusterIP (클러스터 내부 접속)
역할: 클러스터 내부에만 유효한 고정 IP를 할당합니다.

특징: 클러스터 외부에서는 접근할 수 없으며, 주로 클러스터 내부의 다른 파드나 서비스 간 통신에 사용됩니다.

NodePort (클러스터 외부 접속)
역할: 각 **노드(Node)**의 특정 포트를 열어 외부에 서비스를 노출합니다.

특징: 클러스터 외부에서 노드_IP:노출된_포트 주소를 통해 서비스에 접근할 수 있게 됩니다.

```
        > 노드          |
클러스터                | > 파드 > 컨테이너
        > 네임스페이스  |
```

노드와 네임스페이스의 역할
노드(Node): 파드가 **어디(어떤 서버)**에 있는지 확인하는 용도입니다. 이는 파드의 물리적인 실행 위치를 알려줍니다. kubectl get pods -o wide 명령어를 사용하면 NODE 컬럼에서 파드가 실행 중인 노드를 확인할 수 있습니다.

네임스페이스(Namespace): 파드가 어떤 그룹에 속해 있는지 확인하는 용도입니다. 이는 파드의 논리적인 소속을 나타냅니다. kubectl get pods --namespace <네임스페이스_이름> 명령어를 통해 특정 그룹에 있는 파드를 조회할 수 있습니다.


RBAC 역활 기반 접근 제어
ACL 스텐다드 확장

인증서
DN DC,OU,CN


# 볼룸

## 1. 문제점: 컨테이너는 일회용입니다
가장 먼저 알아야 할 것은 **컨테이너는 기본적으로 일회용(Ephemeral)**이라는 사실입니다.

컨테이너는 마치 포스트잇과 같습니다. 무언가를 적어두었다가 떼어서 버리면 그 안의 내용은 영원히 사라집니다. 마찬가지로, 컨테이너 안에 파일을 저장해 두어도 컨테이너가 어떤 이유로든 재시작되거나 삭제되면 그 안의 데이터는 모두 사라집니다. 데이터베이스나 중요한 사용자 파일이 이렇게 사라진다면 큰일이겠죠.

## 2. 해결책: 볼륨(Volume) - 컨테이너의 외장하드
쿠버네티스 볼륨은 이 문제를 해결하기 위한 **'컨테이너의 외장하드'**와 같습니다.

볼륨은 파드(Pod)에 장착할 수 있는 저장 공간입니다. 컨테이너가 포스트잇이라면, 볼륨은 따로 들고 다니는 USB 메모리나 외장하드입니다. 포스트잇을 찢어 버려도 외장하드에 있는 데이터는 그대로 남아있는 것처럼, 컨테이너가 재시작되어도 볼륨에 저장된 데이터는 안전하게 보존됩니다.

핵심 특징:
볼륨의 생명주기는 컨테이너가 아닌 파드(Pod)에 연결됩니다.
파드가 살아있는 동안에는, 그 안의 컨테이너가 재시작되어도 볼륨 데이터는 유지됩니다.
하나의 파드 안에 여러 컨테이너가 있을 경우, 이 컨테이너들은 같은 볼륨을 공유하여 데이터를 주고받을 수 있습니다.

## 3. 볼륨의 종류와 용도
쿠버네티스는 다양한 종류의 볼륨을 지원하며, 용도에 따라 선택해서 사용합니다.

emptyDir:
개념: 파드가 생성될 때 함께 만들어지는 임시 폴더입니다. 파드가 사라지면 이 폴더도 함께 삭제됩니다.

비유: 회의실(파드) 안에 있는 화이트보드. 회의에 참여한 여러 사람(컨테이너)들이 함께 쓰고 지울 수 있지만, 회의가 끝나면(파드가 삭제되면) 내용도 모두 지워집니다.

용도: 하나의 파드 내 컨테이너 간의 임시 파일 공유, 캐시 데이터 저장 등

hostPath:

개념: 컨테이너가 실행 중인 노드(서버)의 실제 폴더를 파드에 연결합니다.

비유: 아파트(노드)의 특정 방(폴더) 열쇠를 컨테이너에게 주는 것과 같습니다.

용도: 노드의 로그 파일을 읽거나, 도커 소켓에 접근하는 등 특수한 경우에 사용됩니다.

⚠️ 주의: 파드가 특정 노드에 묶이게 되므로 꼭 필요한 경우에만 제한적으로 사용해야 합니다.

awsElasticBlockStore, gcePersistentDisk, nfs (네트워크 볼륨):

개념: AWS의 EBS, Google Cloud의 Persistent Disk, 사내 파일 서버(NFS) 같은 외부 네트워크 스토리지를 파드에 직접 연결합니다.

비유: 파드를 외부의 전문적인 물류 창고에 연결하는 것과 같습니다. 파드나 노드가 사라져도 데이터는 창고에 안전하게 보관됩니다.

용도: 데이터베이스 파일, 사용자 업로드 파일 등 영구적으로 보존해야 할 중요한 데이터 저장.

## 4. 가장 좋은 방법: PV와 PVC
위의 네트워크 볼륨을 직접 사용하는 것은, 개발자가 인프라(AWS 볼륨 ID 등) 정보를 알아야 하므로 좋은 방법이 아닙니다. 그래서 쿠버네티스는 **PV(PersistentVolume)**와 **PVC(PersistentVolumeClaim)**라는 더 발전된 방법을 사용합니다.

레스토랑의 외투 보관소에 비유할 수 있습니다.

관리자 (인프라 담당자):

외투 보관소 직원처럼, 미리 다양한 종류의 저장 공간(PV)을 준비해 둡니다. "이건 5GB짜리 빠른 SSD", "저건 100GB짜리 느린 HDD"처럼 말이죠.

개발자 (애플리케이션 담당자):

레스토랑 손님처럼, 보관소에 가서 "제 외투를 맡길 공간 하나 주세요"라고 **요청(PVC)합니다. "10GB 정도의 빠른 공간이 필요해요" 라고만 말하면 됩니다.

쿠버네티스:

손님의 요청(PVC)에 맞는 저장 공간(PV)을 찾아서 자동으로 연결해주고 '보관증'을 줍니다. 개발자는 이 '보관증'만 파드 설정에 넣으면 됩니다.

PV (PersistentVolume): 관리자가 미리 준비해 둔 실제 저장 공간 (추상화)

PVC (PersistentVolumeClaim): 개발자가 "이만큼의 공간이 필요해요" 라고 하는 저장 공간 요청서


-------------------------------------------------------------------------

## 실습

kubectl create namespace ns1
kubectl create deployment ui --image=nginx -n ns1

kubectl create namespace ns2
kubectl create deployment ui --image=nginx -n ns2

kubectl create namespace ns3
kubectl create deployment ui --image=nginx -n ns3

kubectl get namespace
kubectl get pods --namespace ns1
kubectl get pods --namespace ns2
kubectl get pods --namespace ns3

kubectl create namespace ns2 --dry-run=client -o yaml > ns2.yaml 

vim ns1.yaml
```
apiVersion: v1
kind: Namespace
metadata:
  creationTimestamp: null
  name: n2
spec: {}
status: {}
```

kubectl create -f ns2.yaml 

kubectl delete namespace ns1 ns2

## yaml
vim nginx.yml
```
apiVersion: v1
kind: Pod
metadata:
  name: web-nginx # <-- metadata 아래에 들여쓰기
spec:
  containers: # <-- spec 아래에 들여쓰기
  - name: nginx # <-- - 아래에 들여쓰기, 다른 항목과 동일 레벨
    image: nginx:1.14
    ports:
    - containerPort: 80 # <-- - ports 아래에 들여쓰기
```
kubectl create -f nginx.yml 
kubectl get pods --namespace default

kubectl get pods --namespace kube-system
kubectl get pods --all-namespaces

kubectl create namespace ns1
kubectl create namespace ns2 --dry-run=client -o yaml > ns2.yaml

vim ns2.yaml 
```
apiVersion: v1
kind: Namespace
metadata:
  name: ns2
```

kubectl create -f ns2.yaml 
kubectl get namespace

kubectl create -f nginx.yml --namespace ns1

vim nginx.yml
```
apiVersion: v1
kind: Pod
metadata:
  name: web-nginx
  namespace: ns2
spec:
  containers:
  - name: nginx
    image: nginx:1.14
    ports:
    - containerPort: 80
    - containerPort: 443
```

kubectl create -f nginx.yml 
kubectl get pods --namespace ns1
kubectl get pods --namespace ns2

kubectl config current-context

kubectl config view

kubectl config set-context ns1@kubernetes --cluster=kubernetes --user=kubernetes-admin --namespace=ns1

kubectl config view

kubectl config use-context ns1@kubernetes
kubectl config current-context

kubectl get pods (명령에서 namespace 생략하면 ns1이다.)
kubectl get pods --namespace ns1
kubectl get pods --namespace default 

kubectl delete pods web-nginx --namespace default

kubectl config use-context kubernetes-admin@kubernetes 

kubectl config current-context

kubectl get pods --namespace ns1

kubectl config rename-context ns1@kubernetes n1@kubernetes

root@master:~# kubectl config set-context n1@kubernetes --cluster=kubernetes --user=kubernetes-admin --namespace=n1

kubectl config use-context n1@kubernetes

kubectl delete namespace ns1 
kubectl get pods --namespace ns1
kubectl config delete-context ns1@kubernetes

kubectl config view

## Emptydir 실습

```
apiVersion: v1
kind: Pod
metadata:
  name: sidecar
spec:
  containers:
  - name: app
    image: busybox
    args:
    - /bin/sh
    - -c
    - |
      while true;
      do
        echo "$(date)" >> /var/log/example.log;
        sleep 1;
      done
    volumeMounts:
    - name: varlog
      mountPath: /var/log
  - name: sidecar-logger
    image: busybox
    args: [/bin/sh, -c, "tail -f /var/log/example.log"]
    volumeMounts:
    - name: varlog
      mountPath: /var/log
  volumes:
  - name: varlog
    emptyDir: {}
```