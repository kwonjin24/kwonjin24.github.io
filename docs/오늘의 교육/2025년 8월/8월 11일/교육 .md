---
layout: default
title: 
parent: 8월 11일
nav_order: 2
---

# 2025년 8월 11일 교육 내용

# 쿠버네티스 

## 1. IaC (Infrastructure as Code) - 코드로 인프라 구축

설명: 서버, 데이터베이스, 네트워크 같은 인프라 자원을 마우스로 클릭해서 만드는 것이 아니라, 코드를 사용하여 정의하고 자동으로 구축하는 방식입니다. 대표적인 도구로 테라폼(Terraform), AWS 클라우드포메이션(CloudFormation) 등이 있습니다.

핵심 장점:

자동화: 수동 작업이 없어지므로 빠르고 실수가 줄어듭니다.
재현성: 똑같은 인프라 환경을 몇 번이고 동일하게 만들 수 있습니다.
버전 관리: 코드처럼 인프라의 변경 이력을 추적하고 관리할 수 있습니다.

비유: 건물을 지을 때마다 감으로 짓는 것이 아니라, 모든 구조와 자재가 명시된 **'설계도(코드)'**를 만들어 두고, 이 설계도만 있으면 언제 어디서든 똑같은 건물을 지을 수 있는 것과 같습니다.
파드 : 버네티스에서 생성하고 관리할 수 있는 가장 작고 기본적인 배포 단위입니다. 컨테이너들을 담는 '컨테이너의 집'이라고 할 수 있습니다.

네, 작성해주신 메모들을 더 이해하기 쉽고 체계적으로 다듬어 드릴게요. 클라우드와 쿠버네티스의 핵심 개념들이네요.

--------------------------------------------------------

## 2. 파드 (Pod) - 컨테이너들의 집

설명: 쿠버네티스에서 생성하고 관리하는 가장 작은 배포 단위입니다. 파드는 한 개 이상의 컨테이너 그룹을 감싸는 껍데기와 같습니다.

핵심 특징:
파드 안의 컨테이너들은 네트워크와 저장 공간(스토리지)을 공유합니다. 마치 한집에 사는 가족들이 같은 주소(IP)와 창고(볼륨)를 쓰는 것과 같습니다.

보통 하나의 파드에는 하나의 핵심 컨테이너를 두는 것이 일반적이며, 로그 수집 등 보조적인 역할의 컨테이너를 함께 넣기도 합니다(사이드카 패턴).

정리: 컨테이너가 '애플리케이션(프로그램)' 그 자체라면, 파드는 그 애플리케이션과 그것이 사용하는 **환경(네트워크, 스토리지)을 함께 묶은 '실행 단위'**입니다.

--------------------------------------------------------

# 3. API 서버 (API Server) - 클러스터의 공식 소통 창구
"API 서버는 마스터 노드(컨트롤 플레인)의 데몬이다"는 기술적으로 맞는 말입니다. 하지만 역할의 관점에서 보면 더 중요한 의미가 있습니다.

역할: 쿠버네티스 클러스터의 모든 요청이 거쳐가는 유일한 관문이자 중앙 통제소입니다.

설명: 개발자가 kubectl 명령을 내릴 때, 클러스터 내부의 다른 부품들이 서로 통신할 때, 심지어 노드가 자신의 상태를 보고할 때도 모두 이 API 서버를 통해서만 이야기합니다. API 서버는 모든 요청을 검증하고 etcd에 저장하며, 다른 부품들에게 필요한 작업을 지시합니다.

비유: 회사의 **'중앙 비서실'**과 같습니다. 모든 업무 지시와 보고는 반드시 이 비서실을 통해서만 이루어지며, 비서실은 모든 것을 기록하고 각 부서에 업무를 전달합니다.

--------------------------------------------------------

## 4. 개발 → 스테이징 → 프로덕션: 서비스 배포의 흐름
이것은 소프트웨어가 개발되어 사용자에게 전달되기까지 거치는 표준적인 환경 단계를 의미합니다.

① 개발 (Development): 개발자들이 자신의 컴퓨터에서 코드를 작성하고 기능을 만드는 '작업실' 단계입니다.

② 스테이징 (Staging): 실제 운영 환경(프로덕션)과 거의 동일하게 복제된 **'리허설 무대'**입니다. 개발된 코드를 사용자에게 공개하기 전에 최종 테스트를 하고, 다른 기능들과 충돌은 없는지, 성능에 문제는 없는지 등을 검증하는 단계입니다.

③ 프로덕션 (Production): 실제 사용자들이 서비스를 이용하는 **'실제 공연 무대'**입니다. 이곳에서 문제가 발생하면 서비스 장애로 이어지기 때문에, 스테이징 단계에서 충분한 검증을 거친 후에 배포가 이루어집니다.

--------------------------------------------------------

## 5. 선언형 API (Declarative API) - "결과를 말해줘"
"쿠버네티스는 선언적 명령을 사용한다"는 쿠버네티스의 가장 중요한 철학 중 하나입니다.

명령형 (Imperative) 방식: "어떻게" 할지 과정 하나하나를 지시하는 방식입니다.

    예 :  "서버 A에 접속해. 도커를 설치해. 앱 이미지를 다운받아. 80번 포트로 실행해."

선언형 (Declarative) 방식: **"어떤 상태(결과)가 되어야 하는지"**를 선언하는 방식입니다. 과정은 시스템이 알아서 처리합니다.
    예 : "이 앱 컨테이너 3개가 항상 실행 중인 상태여야 해." (YAML 파일에 정의)

쿠버네티스는 바로 이 선언형 방식을 사용합니다. 사용자가 YAML 파일에 "최종적으로 원하는 상태"를 정의해서 제출하면, 쿠버네티스의 컨트롤러들은 현재 상태를 계속 감시하다가 원하는 상태와 달라지면 스스로 알아서 그 상태를 맞추려고 노력합니다. (이를 'Self-healing', 자가 치유 능력이라고 합니다)

비유: 식당에서 주문할 때, 주방장에게 "고기를 꺼내서, 소금을 뿌리고, 2분간 굽고..." 라고 과정을 지시하는 것(명령형)이 아니라, "미디엄 레어 스테이크 하나 주세요" 라고 원하는 결과(선언형)를 말하는 것과 같습니다. 그러면 주방장(쿠버네티스)이 알아서 최상의 결과물을 만들어냅니다

--------------------------------------------------------

## 기본 단위 (Basic Units)
🔹 클러스터 (Cluster)
설명: 쿠버네티스에 의해 함께 관리되는 컴퓨터(서버)들의 집합 전체를 의미합니다. 컨트롤 플레인과 여러 개의 노드로 구성된 쿠버네티스 시스템 그 자체를 말합니다.

비유: 하나의 '오케스트라' 또는 '회사' 전체입니다.

🔹 노드 (Node)
설명: 클러스터에 속한 개별 컴퓨터(서버) 한 대 한 대를 의미합니다. 이곳은 애플리케이션(파드)이 실제로 배치되어 실행되는 작업 공간입니다.

비유: 오케스트라의 '연주자' 한 명 한 명, 또는 회사의 '팀원'입니다.

🔹 파드 (Pod)
설명: 쿠버네티스에서 생성하고 관리할 수 있는 가장 작은 배포 단위입니다. 파드는 하나 이상의 컨테이너와 그 컨테이너들이 공유하는 저장 공간(볼륨), 네트워크 IP 등으로 구성됩니다. 보통 하나의 파드에는 하나의 컨테이너를 넣는 것이 일반적입니다.

비유: 연주자가 연주하는 '악보 한 장' 또는 팀원이 수행하는 '업무 카드 한 개'입니다. 이 악보에는 어떤 노래(컨테이너)를 연주해야 하는지가 적혀있습니다.

--------------------------------------------------------

## 🧠 컨트롤 플레인 (Control Plane): 관리자 그룹  
클러스터를 관리하고 지휘하는 두뇌 역할을 하는 컴포넌트들의 집합입니다.

🔹 API 서버 (API Server)  
설명: 클러스터의 모든 통신이 거쳐가는 유일한 공식 창구입니다. 사용자의 명령, 내부 컴포넌트 간의 통신 등 모든 요청을 접수하고, 인증하며, 다른 컴포넌트에 전달하는 중앙 관제소입니다.

비유: 회사의 'CEO 비서실' 또는 오케스트라의 '총무'입니다. 모든 보고와 요청은 반드시 비서실을 통해서만 CEO(etcd)나 다른 부서(스케줄러, 컨트롤러)에 전달될 수 있습니다.

🔹 etcd  
설명: 클러스터의 모든 설정 값과 상태 정보를 저장하는 핵심 데이터베이스입니다. "어떤 파드가 어느 노드에 있는지", "서비스는 어떻게 설정되어 있는지" 등 모든 것을 기록하고 보관하는 클러스터의 '기억 장치'입니다.

비유: 회사의 '모든 정보가 기록된 원장(Ledger)' 또는 CEO의 '두뇌'입니다. 비서실(API 서버)을 통해 이 원장에 정보를 기록하거나 조회합니다.

🔹 스케줄러 (Scheduler)  
설명: 새로 생성된 파드를 어느 노드에 배치할지 결정하는 역할을 하는 컴포넌트입니다. 각 노드의 자원 사용량이나 특정 요구사항을 분석하여 가장 적합한 노드를 찾아줍니다.

비유: 회사의 **'자원 배치팀(HR)'**입니다. 신규 프로젝트(파드)가 들어왔을 때, 어느 팀(노드)에 배정해야 가장 효율적일지 판단하여 배치해 줍니다.

🔹 컨트롤러 매니저 (Controller Manager)  
설명: 클러스터의 현재 상태가 사용자가 정의한 '원하는 상태'와 일치하도록 지속적으로 감시하고 조절하는 역할을 합니다. 다양한 종류의 컨트롤러(노드 컨트롤러, 레플리케이션 컨트롤러 등)를 실행하며, 상태에 변화가 생기면 자동으로 바로잡습니다.

비유: 회사의 **'프로젝트 매니저(PM) 그룹'**입니다. "A 프로젝트는 항상 3명의 팀원이 있어야 한다"는 규칙을 계속 확인하다가, 한 명이 퇴사하면 즉시 자원 배치팀(스케줄러)에 인원 충원을 요청하는 역할을 합니다.

--------------------------------------------------------

## 💪 노드 (Node): 실무자 그룹  
실제 작업이 이루어지는 각 노드 서버 안에서 동작하는 컴포넌트들입니다.  

🔹 큐블릿 (Kubelet)  
설명: 각 노드에 하나씩 존재하며 컨트롤 플레인의 지시를 받아 수행하는 에이전트입니다. API 서버로부터 "이 파드를 실행시켜!"라는 명령을 받으면, 컨테이너 런타임을 통해 컨테이너를 실행하고, 파드가 정상적으로 동작하는지 상태를 점검하여 컨트롤 플레인에 보고하는 현장 감독관입니다.

비유: 회사의 **'각 팀의 팀장'**입니다. 상부(컨트롤 플레인)의 지시를 받아 팀원(컨테이너)에게 실제 업무를 할당하고, 업무 진행 상황을 계속해서 상부에 보고합니다.

🔹 큐브 프록시 (Kube-proxy)  
설명: 각 노드의 네트워크 규칙을 관리하는 컴포넌트입니다. 파드들이 서로 통신하거나 외부와 통신할 수 있도록 IP 주소와 포트를 연결해주고 트래픽을 전달하는 역할을 합니다.

비유: 회사의 **'사내 네트워크 관리자'**입니다. 팀원들이 서로 원활하게 소통하고 외부와 이메일이나 전화를 주고받을 수 있도록 통신망을 관리해 줍니다.

🔹 컨테이너 런타임 (Container Runtime)  
설명: 컨테이너를 실제로 실행하고 관리하는 소프트웨어입니다. 큐블릿의 지시를 받아 컨테이너 이미지를 가져와 실행시키는 실질적인 행동대원입니다. 도커(Docker)가 가장 유명하며, containerd, CRI-O 등도 있습니다.

비유: 팀장이 지시한 업무를 수행하는 '실무를 처리하는 팀원' 또는 연주자가 연주하는 '악기' 자체입니다.

--------------------------------------------------------

＃ 클러스트 아키텍처

## 🏗️ 클러스터 (Cluster)
클러스터는 쿠버네티스의 가장 기본이 되는 실행 단위입니다. 간단히 말해, 여러 대의 컴퓨터(서버)를 하나로 묶어 거대한 단일 컴퓨터처럼 동작하게 만든 집합을 의미합니다.

역할: 컨테이너화된 애플리케이션을 배포하고 관리하는 전체 환경입니다.

구성 요소:

컨트롤 플레인 (Control Plane): 클러스터 전체를 관리하고 지휘하는 "두뇌" 역할을 합니다. 어떤 애플리케이션을 몇 개 실행할지, 어떻게 연결할지 등을 결정하고 명령합니다. (옛날에는 마스터 노드라고 불렀습니다.)

워커 노드 (Worker Node): 컨트롤 플레인의 명령을 받아 실제 애플리케이션(파드)을 실행하는 "일꾼" 역할을 하는 서버들입니다.

** analogy 비유**: 오케스트라와 같습니다. 컨트롤 플레인은 모든 연주자에게 무엇을 연주할지 지시하는 지휘자이고, 워커 노드는 각자의 악기를 연주하는 연주자들입니다. 이들이 모여 하나의 멋진 음악(애플리케이션)을 만들어내는 것이 바로 클러스터입니다.

--------------------------------------------------------

## 🔌 CNI (Container Network Interface)
사용자께서 이해하신 "파드가 생성되면 IP를 주어진다"가 정확합니다!

CNI는 쿠버네티스가 컨테이너(파드)에 **네트워크 기능을 제공하는 방법에 대한 표준 규약(인터페이스)**입니다. 쿠버네티스 자체는 네트워크를 직접 설정하지 않고, CNI 표준을 따르는 "네트워크 플러그인"에게 그 역할을 위임합니다.

핵심 기능:
새로운 파드(Pod)가 생성될 때마다 고유한 IP 주소를 할당합니다.
같은 워커 노드에 있는 파드들끼리 통신할 수 있게 해줍니다.
서로 다른 워커 노드에 있는 파드들끼리도 통신할 수 있게 해줍니다.

종류: Calico, Flannel, Cilium 등 다양한 CNI 플러그인이 있으며, 필요에 따라 선택하여 설치합니다.

** analogy 비유**: 집에 있는 전기 콘센트 규격과 같습니다. 한국에서는 220V 둥근 모양이라는 표준(CNI)이 정해져 있죠. 그러면 여러 회사(Calico, Flannel 등)가 그 표준에 맞는 콘센트(CNI 플러그인)를 만듭니다. 우리는 어떤 회사의 콘센트인지 신경 쓸 필요 없이, 그냥 가전제품(파드)의 플러그를 꽂으면 전기를 쓸 수(네트워크 통신을 할 수) 있습니다.

--------------------------------------------------------

## 📦 CRI (Container Runtime Interface)
CRI는 쿠버네티스가 컨테이너를 **실행하고 관리하는 방법에 대한 표준 규약(인터페이스)**입니다.

과거에는 쿠버네티스가 '도커(Docker)'라는 특정 컨테이너 기술에만 의존했습니다. 하지만 더 다양한 컨테이너 런타임을 지원하기 위해 CRI라는 표준을 만들었습니다. 각 노드의 kubelet이라는 에이전트가 CRI를 통해 컨테이너 런타임에게 "이 이미지로 컨테이너를 시작해줘" 또는 "저 컨테이너를 중지해줘" 같은 명령을 내립니다.

핵심 기능: 컨테이너 이미지 가져오기, 컨테이너 시작/중지, 컨테이너 상태 확인 등 컨테이너의 생명주기를 관리하는 명령을 표준화합니다.

CRI 호환 런타임: containerd, CRI-O 등이 널리 사용됩니다. (현재 쿠버네티스는 도커를 직접 지원하지 않고, CRI 호환 런타임인 containerd를 통해 컨테이너를 실행합니다.)

** analogy 비유**: USB 포트와 같습니다. 컴퓨터(쿠버네티스)는 USB라는 표준(CRI)만 지원하면, 로지텍 마우스든, 삼성 키보드든, 샌디스크 USB 메모리든(다양한 컨테이너 런타임) 어떤 장치든지 꽂아서 사용할 수 있습니다.

--------------------------------------------------------

## 🚦 LB (Load Balancer)
LB는 **로드 밸런서(Load Balancer)**의 약자로, 여러 서버(파드)에 들어오는 트래픽(요청)을 균등하게 분산시켜주는 장치입니다.

쿠버네티스 클러스터 안에서 실행되는 애플리케이션을 외부 사용자가 접속할 수 있게 하려면 입구가 필요합니다. 로드 밸런서는 이 입구 역할을 하며, 특정 서버에 과부하가 걸리지 않도록 트래픽을 여러 파드에 골고루 나누어 줍니다.

핵심 기능:
단일 진입점 제공: 외부 사용자는 복잡한 내부 구조를 몰라도 로드 밸런서의 고정된 IP 주소 하나만으로 서비스에 접근할 수 있습니다.
트래픽 분산: 요청을 여러 파드에 나누어주어 안정성과 성능을 높입니다.
고가용성: 특정 파드에 문제가 생기면, 로드 밸런서는 자동으로 해당 파드를 제외하고 건강한 다른 파드들에게만 트래픽을 보내 서비스 중단을 방지합니다.

** analogy 비유**: 놀이공원의 인기 있는 놀이기구 앞의 안내 요원과 같습니다. 사람들이 한 줄로만 서면 대기 시간이 길어지니, 안내 요원(로드 밸런서)이 "1번 탑승구로 가세요", "2번 탑승구로 가세요" 하고 사람들을 여러 탑승구(파드)로 나누어 보내는 것과 같습니다.

--------------------------------------------------------

## 📝 json (JavaScript Object Notation) & yaml (YAML Ain't Markup Language)
JSON과 YAML은 둘 다 데이터를 표현하는 형식입니다. 쿠버네티스에서는 "우리가 원하는 상태(Desired State)"를 정의하는 설정 파일(Manifest)을 작성할 때 사용합니다. 즉, 쿠버네티스에게 무엇을 어떻게 실행할지 명령을 내리는 설계도를 작성하는 언어입니다.

JSON
{ "key": "value" } 형식으로 중괄호와 따옴표를 사용합니다.
기계가 읽고 처리하기에 매우 효율적입니다.
하지만 사람이 직접 작성하기에는 괄호, 쉼표, 따옴표 때문에 다소 복잡하고 가독성이 떨어집니다.
```
{
  "apiVersion": "v1",
  "kind": "Pod",
  "metadata": {
    "name": "my-pod"
  },
  "spec": {
    "containers": [
      {
        "name": "nginx",
        "image": "nginx:latest"
      }
    ]
  }
}
```

YAML
들여쓰기와 키: 값 형식을 사용해 구조를 표현합니다.
사람이 읽고 쓰기에 훨씬 편리하고 직관적입니다.
주석(#)을 사용할 수 있어 설정에 대한 설명을 추가하기 좋습니다.
이러한 장점 때문에 쿠버네티스 설정 파일은 대부분 YAML로 작성합니다.
```
# Nginx 파드를 정의하는 설정 파일
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
    - name: nginx
      image: nginx:latest
```
--------------------------------------------------------

## ⚙️ Kubelet, CRI, 그리고 containerd의 관계
사용자께서 적어주신 kubelet -> CRI -> containerd 흐름은 현재 쿠버네티스의 동작 방식을 매우 정확하게 표현한 것입니다. 각 요소가 어떻게 상호작용하는지 살펴보겠습니다.

kubelet (큐블릿)

역할: 클러스터의 모든 워커 노드(Worker Node)에서 실행되는 핵심 에이전트입니다.

임무: 컨트롤 플레인(지휘부)으로부터 "어떤 파드를 실행시켜라"는 명령(PodSpec)을 받습니다. 그리고 해당 파드가 노드에서 정상적으로 실행되고 건강한 상태를 유지하도록 관리하는 현장 감독관 역할을 합니다.

CRI (Container Runtime Interface)

역할: kubelet과 컨테이너 런타임 사이의 **표준 통신 규약(API)**입니다.

목적: 과거 쿠버네티스는 특정 컨테이너 기술(도커)에 의존했습니다. 이 의존성을 없애고, 어떤 컨테이너 런타임이든 "플러그인"처럼 갈아 끼울 수 있도록 하기 위해 CRI라는 표준 인터페이스를 만들었습니다. kubelet은 이제 "컨테이너를 시작해줘"라는 표준화된 CRI 명령만 내리면 됩니다.

containerd (컨테이너디)

역할: CRI 표준을 구현한 고성능 컨테이너 런타임입니다.

임무: kubelet으로부터 CRI 명령을 받아, 실제로 컨테이너 이미지를 내려받고, 컨테이너를 생성하며, 시작/중지하는 등 실질적인 컨테이너 실행을 담당하는 작업자입니다. 원래는 도커 엔진의 일부였으나, 독립적인 오픈소스 프로젝트로 분리되었습니다.

** analogy 비유**: 레스토랑으로 비유할 수 있습니다.
**kubelet**은 손님의 주문서(PodSpec)를 주방에 전달하는 매니저입니다.
**CRI**는 매니저와 셰프가 소통하는 표준 주문 용어("스테이크 하나, 미디움 레어")입니다.
**containerd**는 표준 용어에 따라 실제로 스테이크를 굽는 셰프입니다.

--------------------------------------------------------

| 상태 (Phase) | 의미 | 설명 |
| :--- | :--- | :--- |
| **Pending** | **대기 중** | 파드가 클러스터에 생성 요청은 되었지만, 아직 실행 준비가 완료되지 않은 상태입니다. <br> • 컨테이너 이미지를 다운로드 중일 수 있습니다. <br> • 파드를 실행할 적절한 노드를 아직 찾지 못했을 수 있습니다. |
| **Running** | **실행 중** | 파드가 노드에 성공적으로 할당되었고, 파드 내의 **모든 컨테이너가 생성된 상태**입니다. <br> • 이 상태에서 최소 하나 이상의 컨테이너가 실제로 실행 중이거나, 시작 또는 재시작하는 과정에 있습니다. |
| **Succeeded** | **성공** | 파드 내의 **모든 컨테이너가 정상적으로 작업을 완료하고 종료**했으며, 다시는 재시작되지 않을 상태입니다. <br> • 주로 계산이나 데이터 처리 같은 일회성 작업(Job)을 실행하는 파드에서 볼 수 있습니다. |
| **Failed** | **실패** | 파드 내의 **모든 컨테이너가 종료**되었고, 그중 **최소 하나 이상의 컨테이너가 오류를 일으키며(비정상 종료) 종료**된 상태입니다. |
| **Unknown** | **알 수 없음** | 파드가 실행 중인 노드와의 통신 문제 등으로 인해 **파드의 상태를 확인할 수 없는 상태**입니다. |

--------------------------------------------------------

## 🏗️ 쿠버네티스 CRI 구조 변경 (Dockershim의 제거)
이것은 쿠버네티스 역사에서 매우 중요한 변화입니다.

과거 방식: Dockershim 사용 (K8s v1.23 이전)
초기 쿠버네티스는 **도커(Docker)**를 실행하기 위해 만들어졌습니다. 그래서 kubelet 코드 안에 도커와 직접 통신하는 코드가 포함되어 있었습니다.
이후 CRI 표준이 생기면서, 기존 도커 API와 CRI 표준을 연결해주는 번역기 역할의 Dockershim이라는 중간 계층이 kubelet 내부에 포함되었습니다.

문제점:
쿠버네티스 프로젝트가 특정 기술(도커)을 위한 번역기를 직접 유지보수해야 하는 부담이 있었습니다.
kubelet -> Dockershim -> Docker -> containerd 순으로 호출되어 불필한 단계가 존재했고 구조가 복잡했습니다.

현재 방식: 표준 CRI 직접 통신 (K8s v1.24 이후)
쿠버네티스 프로젝트는 Dockershim을 코드에서 완전히 제거했습니다.
이제 모든 컨테이너 런타임은 반드시 CRI 표준을 직접 지원해야 합니다.
containerd나 CRI-O 같은 런타임들은 이미 CRI를 완벽하게 지원하므로, kubelet이 중간 번역기 없이 직접 통신할 수 있게 되었습니다.

결과:
구조 단순화: kubelet -> containerd로 이어지는 호출 단계가 간소화되었습니다.
유지보수 효율성 증가: 쿠버네티스 프로젝트는 더 이상 특정 런타임을 위한 코드를 관리할 필요가 없어졌습니다.
표준화 강화: 컨테이너 생태계가 CRI라는 단일 표준을 중심으로 더욱 견고해졌습니다.

--------------------------------------------------------

쿠버네티스 설치 방법
